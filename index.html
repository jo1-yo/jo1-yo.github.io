<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jane's Portfolio | Four Seasons</title>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@300;400;500;600&family=Libre+Baskerville:ital@0;1&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: 'Cormorant Garamond', serif;
            background: #1a1a1a;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .ui-overlay {
            position: fixed;
            z-index: 100;
            pointer-events: none;
        }

        .season-indicator {
            position: fixed;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            text-align: center;
        }

        .season-name {
            font-family: 'Libre Baskerville', serif;
            font-size: 4rem;
            font-weight: 400;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            opacity: 0;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            text-shadow: 0 2px 20px rgba(0,0,0,0.3);
            transition: opacity 0.5s ease;
        }

        .season-name.spring { color: #f5b7c5; }
        .season-name.summer { color: #7dd87d; }
        .season-name.autumn { color: #e8a649; }
        .season-name.winter { color: #c5dff5; }

        .season-name.active {
            animation: seasonFadeInOut 3s ease forwards;
        }

        @keyframes seasonFadeInOut {
            0% { opacity: 0; transform: translateX(-50%) scale(0.9); }
            10% { opacity: 1; transform: translateX(-50%) scale(1); }
            70% { opacity: 1; transform: translateX(-50%) scale(1); }
            85% { opacity: 1; transform: translateX(-50%) scale(1.05); }
            90% { opacity: 0.5; transform: translateX(-50%) scale(1); }
            100% { opacity: 0; transform: translateX(-50%) scale(1); }
        }

        .hint-text {
            position: fixed;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            font-size: 1.1rem;
            letter-spacing: 0.2em;
            color: rgba(255,255,255,0.6);
            text-transform: uppercase;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 0.8; }
        }

        .scroll-indicator {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            gap: 12px;
        }

        .scroll-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255,255,255,0.3);
            transition: all 0.3s ease;
            cursor: pointer;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .scroll-dot:hover {
            background: rgba(255,255,255,0.6);
            transform: scale(1.15);
        }

        .scroll-dot.active {
            background: rgba(255,255,255,0.9);
            transform: scale(1.2);
            border-color: rgba(255,255,255,0.6);
        }

        .project-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(20px);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: all 0.5s ease;
        }

        .project-modal.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            max-width: 700px;
            padding: 60px;
            text-align: center;
            transform: translateY(30px);
            transition: transform 0.5s ease;
        }

        .project-modal.active .modal-content {
            transform: translateY(0);
        }

        .modal-icon {
            font-size: 4rem;
            margin-bottom: 30px;
        }

        .modal-title {
            font-family: 'Libre Baskerville', serif;
            font-size: 2.5rem;
            color: #fff;
            margin-bottom: 20px;
            letter-spacing: 0.05em;
        }

        .modal-description {
            font-size: 1.3rem;
            color: rgba(255,255,255,0.75);
            line-height: 1.8;
            margin-bottom: 25px;
        }

        .modal-status {
            display: inline-block;
            background: rgba(255, 193, 7, 0.3);
            color: #ffc107;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            margin-bottom: 15px;
            letter-spacing: 0.1em;
        }

        .modal-status:empty {
            display: none;
        }

        .modal-links {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 30px;
        }

        .modal-links:empty {
            display: none;
        }

        .modal-link {
            display: inline-block;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            color: #fff;
            padding: 10px 25px;
            font-family: 'Cormorant Garamond', serif;
            font-size: 1rem;
            letter-spacing: 0.1em;
            text-decoration: none;
            border-radius: 25px;
            transition: all 0.3s ease;
        }

        .modal-link:hover {
            background: rgba(255,255,255,0.2);
            border-color: #fff;
            transform: translateY(-2px);
        }

        .modal-close {
            background: transparent;
            border: 1px solid rgba(255,255,255,0.4);
            color: #fff;
            padding: 15px 40px;
            font-family: 'Cormorant Garamond', serif;
            font-size: 1.1rem;
            letter-spacing: 0.2em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .modal-close:hover {
            background: rgba(255,255,255,0.1);
            border-color: #fff;
        }

        .click-hint {
            position: fixed;
            padding: 12px 25px;
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            border-radius: 30px;
            color: #fff;
            font-size: 0.95rem;
            letter-spacing: 0.1em;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease;
            z-index: 200;
        }

        .click-hint.visible {
            opacity: 1;
        }

        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 1s ease;
        }

        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-text {
            font-family: 'Libre Baskerville', serif;
            font-size: 1.5rem;
            color: rgba(255,255,255,0.7);
            letter-spacing: 0.3em;
            margin-bottom: 30px;
        }

        .loading-bar {
            width: 200px;
            height: 2px;
            background: rgba(255,255,255,0.2);
            overflow: hidden;
        }

        .loading-progress {
            width: 0%;
            height: 100%;
            background: #fff;
            transition: width 0.3s ease;
        }

        .name-title {
            position: fixed;
            top: 50%;
            left: 50px;
            transform: translateY(-50%) rotate(-90deg);
            transform-origin: left center;
            z-index: 100;
            font-family: 'Libre Baskerville', serif;
            font-size: 0.85rem;
            letter-spacing: 0.4em;
            color: rgba(255,255,255,0.5);
            text-transform: uppercase;
        }

        .social-links {
            position: fixed;
            bottom: 40px;
            right: 40px;
            z-index: 100;
            display: flex;
            gap: 20px;
        }

        .social-link {
            color: rgba(255,255,255,0.5);
            text-decoration: none;
            font-size: 0.85rem;
            letter-spacing: 0.15em;
            transition: color 0.3s ease;
        }

        .social-link:hover {
            color: #fff;
        }

        .switch-view-btn {
            position: fixed;
            top: 40px;
            right: 40px;
            z-index: 500;
            padding: 12px 24px;
            background: rgba(180, 180, 180, 0.4);
            border: 1px solid rgba(255,255,255,0.5);
            border-radius: 30px;
            color: #333;
            font-family: 'Cormorant Garamond', serif;
            font-size: 0.95rem;
            font-weight: 600;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
            pointer-events: auto;
            box-shadow: 0 2px 10px rgba(0,0,0,0.15);
        }

        .switch-view-btn:hover {
            background: rgba(160, 160, 160, 0.5);
            border-color: rgba(255,255,255,0.8);
            color: #222;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .switch-view-btn svg {
            width: 16px;
            height: 16px;
            fill: #555;
        }
    </style>
</head>
<body>
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-text">ENTERING JANE'S INNER WORLD</div>
        <div class="loading-bar">
            <div class="loading-progress" id="loadingProgress"></div>
        </div>
    </div>

    <div id="canvas-container"></div>

    <div class="season-indicator">
        <div class="season-name spring active" id="springTitle">Spring</div>
        <div class="season-name summer" id="summerTitle">Summer</div>
        <div class="season-name autumn" id="autumnTitle">Autumn</div>
        <div class="season-name winter" id="winterTitle">Winter</div>
    </div>

    <div class="hint-text" id="hintText">Click the apples to explore</div>

    <div class="scroll-indicator">
        <div class="scroll-dot active" data-season="0"></div>
        <div class="scroll-dot" data-season="1"></div>
        <div class="scroll-dot" data-season="2"></div>
        <div class="scroll-dot" data-season="3"></div>
    </div>

    <div class="click-hint" id="clickHint">Click to view project</div>

    <div class="name-title">Jane's Portfolio</div>

    <a href="index-classic.html" class="switch-view-btn">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M4 6h16v2H4zm0 5h16v2H4zm0 5h16v2H4z"/>
        </svg>
        Classic View
    </a>

    <div class="social-links">
        <a href="https://linkedin.com/in/jane-z-439910293" target="_blank" class="social-link">LinkedIn</a>
        <a href="https://github.com/jo1-yo" target="_blank" class="social-link">GitHub</a>
        <a href="mailto:janezhang2033@163.com" class="social-link">Email</a>
    </div>

    <div class="project-modal" id="projectModal">
        <div class="modal-content">
            <div class="modal-icon" id="modalIcon">ğŸ</div>
            <h2 class="modal-title" id="modalTitle">Project Title</h2>
            <div class="modal-status" id="modalStatus"></div>
            <p class="modal-description" id="modalDescription">Project description goes here.</p>
            <div class="modal-links" id="modalLinks"></div>
            <button class="modal-close" onclick="closeModal()">Close</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // ============================================
        // SIMPLEX NOISE å®ç° (ç”¨äºæ ‘çš®ä½ç§»)
        // ============================================
        class SimplexNoise {
            constructor(seed = Math.random()) {
                this.p = new Uint8Array(256);
                this.perm = new Uint8Array(512);
                this.permMod12 = new Uint8Array(512);
                
                for (let i = 0; i < 256; i++) this.p[i] = i;
                for (let i = 255; i > 0; i--) {
                    const n = Math.floor((seed = (seed * 16807) % 2147483647) / 2147483647 * (i + 1));
                    [this.p[i], this.p[n]] = [this.p[n], this.p[i]];
                }
                for (let i = 0; i < 512; i++) {
                    this.perm[i] = this.p[i & 255];
                    this.permMod12[i] = this.perm[i] % 12;
                }
            }
            
            // 3D Simplex noise
            noise3D(x, y, z) {
                const F3 = 1/3, G3 = 1/6;
                const grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
                
                const s = (x + y + z) * F3;
                const i = Math.floor(x + s), j = Math.floor(y + s), k = Math.floor(z + s);
                const t = (i + j + k) * G3;
                const X0 = i - t, Y0 = j - t, Z0 = k - t;
                const x0 = x - X0, y0 = y - Y0, z0 = z - Z0;
                
                let i1, j1, k1, i2, j2, k2;
                if (x0 >= y0) {
                    if (y0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }
                    else if (x0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }
                    else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }
                } else {
                    if (y0 < z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }
                    else if (x0 < z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }
                    else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }
                }
                
                const x1 = x0 - i1 + G3, y1 = y0 - j1 + G3, z1 = z0 - k1 + G3;
                const x2 = x0 - i2 + 2*G3, y2 = y0 - j2 + 2*G3, z2 = z0 - k2 + 2*G3;
                const x3 = x0 - 1 + 3*G3, y3 = y0 - 1 + 3*G3, z3 = z0 - 1 + 3*G3;
                
                const ii = i & 255, jj = j & 255, kk = k & 255;
                
                const dot = (g, x, y, z) => g[0]*x + g[1]*y + g[2]*z;
                const contrib = (t, gi, x, y, z) => t < 0 ? 0 : Math.pow(t, 4) * dot(grad3[gi], x, y, z);
                
                const t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;
                const t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;
                const t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;
                const t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;
                
                const n0 = contrib(t0, this.permMod12[ii + this.perm[jj + this.perm[kk]]], x0, y0, z0);
                const n1 = contrib(t1, this.permMod12[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]], x1, y1, z1);
                const n2 = contrib(t2, this.permMod12[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]], x2, y2, z2);
                const n3 = contrib(t3, this.permMod12[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]], x3, y3, z3);
                
                return 32 * (n0 + n1 + n2 + n3);
            }
        }
        
        const simplex = new SimplexNoise(12345);

        // Projects data
        const projects = [
            {
                id: 1,
                title: "Jane's Blog",
                description: "Built an automated GitHub logging system using Shell scripts and GitHub Actions to generate daily, time-stamped commits.",
                icon: "ğŸ“",
                links: [
                    { label: "View Code", url: "https://github.com/jo1-yo/learning-log" }
                ]
            },
            {
                id: 2,
                title: "AI Relationship Mapper",
                description: "AI-powered relationship mapper that visualizes and analyzes the connections between characters in stories, movies, and real-world networks.",
                icon: "ğŸ”—",
                links: [
                    { label: "View Demo", url: "https://www.youtube.com/watch?v=mQsZdZ9svwM" },
                    { label: "View Project", url: "https://mulerun.com/" }
                ]
            },
            {
                id: 3,
                title: "Pawse",
                description: "A desktop companion that helps students reduce stress through on-demand supportive conversations and intelligent academic scheduling. Your friendly study buddy.",
                icon: "ğŸ¾",
                status: "In Development"
            },
            {
                id: 4,
                title: "Absolute Navigation Lab",
                description: "This study investigates whether learning an absolute spatial reference frame can alter navigation strategies and performance, for which I developed a custom testing app to deploy and run the experimental tasks for the lab.",
                icon: "ğŸ§­",
                links: [
                    { label: "View Code", url: "https://github.com/jo1-yo/Navigation-Training-Study" }
                ]
            },
            {
                id: 5,
                title: "Gensync",
                description: "Bridging the knowledge gap between elderly and young generations. A platform for intergenerational learning and meaningful connections.",
                icon: "ğŸ¤",
                links: [
                    { label: "View Code", url: "https://github.com/ms48-gensync" }
                ]
            },
            {
                id: 6,
                title: "SUAB",
                description: "Student Union Against Bullying. A community-driven initiative to create safer, more inclusive educational environments for everyone.",
                icon: "ğŸ’ª",
                links: [
                    { label: "View Project", url: "https://imjane.top/suab.html" }
                ]
            }
        ];

        // Scene setup
        let scene, camera, renderer, controls;
        let tree, leaves = [], flowers = [], animals = [], fallingLeaves = [], snowflakes = [];
        let interactiveObjects = [];
        let currentSeason = 0;
        let targetSeason = 0;
        let seasonTransition = 0;
        let windTime = 0;
        let mouse = new THREE.Vector2();
        let raycaster = new THREE.Raycaster();
        let hoveredObject = null;

        // Season colors
        const seasonColors = {
            spring: {
                bg: [0.95, 0.92, 0.93],
                leaves: 0x7cb342,
                accent: 0xf8bbd9
            },
            summer: {
                bg: [0.85, 0.95, 0.85],
                leaves: 0x2e7d32,
                accent: 0x81c784
            },
            autumn: {
                bg: [0.98, 0.9, 0.8],
                leaves: 0xe65100,
                accent: 0xffb74d
            },
            winter: {
                bg: [0.88, 0.91, 0.96],      // ç¨å¾®åè“çš„å¤©ç©º
                ground: [0.95, 0.96, 0.98],  // æ›´ç™½çš„åœ°é¢
                leaves: 0x78909c,
                accent: 0xeceff1
            }
        };

        const seasons = ['spring', 'summer', 'autumn', 'winter'];
        const hintTexts = [
            'Click the apples to explore',
            'Click the animals to discover',
            'Click the falling leaves',
            'Click the snowman to discover'
        ];

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0xfaf0e6, 20, 80);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 30);
            camera.lookAt(0, 10, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 10, 0);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 15;
            controls.maxDistance = 40;
            controls.maxPolarAngle = Math.PI / 1.8;
            controls.minPolarAngle = Math.PI / 4;
            controls.enablePan = false;

            // Lighting
            setupLighting();

            // Create tree
            createTree();

            // Create ground
            createGround();

            // Create seasonal elements
            createSpringElements();
            createSummerElements();
            createAutumnElements();
            createWinterElements();

            // Create river for autumn
            createRiver();

            // Events
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('wheel', onWheel, { passive: false });
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mouseup', onMouseUp);
            window.addEventListener('click', onClick);
            window.addEventListener('touchstart', onTouchStart, { passive: false });
            window.addEventListener('touchmove', onTouchMove, { passive: false });
            window.addEventListener('touchend', onTouchEnd);
            window.addEventListener('keydown', onKeyDown);
            
            // æ·»åŠ å­£èŠ‚ç‚¹å‡»åˆ‡æ¢
            setupSeasonDotClicks();

            // Loading simulation
            simulateLoading();

            // Start animation
            animate();
        }

        function setupLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0xfff5e6, 0.4);
            scene.add(ambientLight);

            // Main sun light
            const sunLight = new THREE.DirectionalLight(0xfff5e1, 1.5);
            sunLight.position.set(30, 50, 20);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 10;
            sunLight.shadow.camera.far = 100;
            sunLight.shadow.camera.left = -30;
            sunLight.shadow.camera.right = 30;
            sunLight.shadow.camera.top = 30;
            sunLight.shadow.camera.bottom = -30;
            sunLight.shadow.bias = -0.0001;
            scene.add(sunLight);

            // Fill light
            const fillLight = new THREE.DirectionalLight(0x87ceeb, 0.3);
            fillLight.position.set(-20, 20, -10);
            scene.add(fillLight);

            // Rim light
            const rimLight = new THREE.DirectionalLight(0xffd700, 0.2);
            rimLight.position.set(0, 10, -30);
            scene.add(rimLight);

            // Hemisphere light for sky/ground color
            const hemiLight = new THREE.HemisphereLight(0x87ceeb, 0x3d2817, 0.3);
            scene.add(hemiLight);
        }

        // ============================================
        // å¯è°ƒå‚æ•° - æ ‘å¹²
        // ============================================
        const TRUNK_CONFIG = {
            radiusTop: 0.4,           // é¡¶éƒ¨åŠå¾„
            radiusBottom: 1.2,        // åº•éƒ¨åŠå¾„
            height: 10,               // é«˜åº¦
            radialSegments: 24,       // åœ†å‘¨åˆ†æ®µ (â‰¥24 ä¿è¯å¹³æ»‘)
            heightSegments: 64,       // é«˜åº¦åˆ†æ®µ (â‰¥64 ä¿è¯å™ªå£°ç»†èŠ‚)
            noiseScale: 2.5,          // å™ªå£°ç¼©æ”¾ (è¶Šå¤§è¶Šç»†ç¢)
            noiseStrength: 0.12,      // å™ªå£°å¼ºåº¦ (æ ‘çš®å‡¹å‡¸æ·±åº¦)
            knotCount: 3,             // ç»“ç–¤æ•°é‡
            knotSize: 0.25,           // ç»“ç–¤å¤§å°
            knotStrength: 0.15        // ç»“ç–¤å‡¸èµ·å¼ºåº¦
        };

        // ä¸»æ ‘å¹² mesh å¼•ç”¨ (ç”¨äºå†¬å­£ç§¯é›ª)
        let trunkMesh = null;
        let branchMeshes = [];

        function createTree() {
            tree = new THREE.Group();

            // åˆ›å»ºé«˜ç²¾åº¦çœŸå®æ„Ÿæ ‘å¹²
            trunkMesh = createRealisticTrunk();
            tree.add(trunkMesh);

            // Main branches (ä¿å­˜å¼•ç”¨ç”¨äºå†¬å­£ç§¯é›ª)
            branchMeshes = [];
            createBranches(tree);

            // Foliage
            createFoliage(tree);

            scene.add(tree);
        }

        // ============================================
        // åˆ›å»ºçœŸå®æ„Ÿæ ‘å¹² (Simplex Noise + ç»“ç–¤)
        // ============================================
        function createRealisticTrunk() {
            const cfg = TRUNK_CONFIG;
            
            // é«˜ç²¾åº¦åœ†æŸ±å‡ ä½•ä½“
            const trunkGeo = new THREE.CylinderGeometry(
                cfg.radiusTop,
                cfg.radiusBottom,
                cfg.height,
                cfg.radialSegments,
                cfg.heightSegments,
                false  // ä¸å°å£ï¼Œä¾¿äºæŸ¥çœ‹æ•ˆæœ
            );

            const positions = trunkGeo.attributes.position;
            const normals = trunkGeo.attributes.normal;
            
            // å®šä¹‰ç»“ç–¤ä½ç½® (é«˜åº¦æ¯”ä¾‹, è§’åº¦)
            const knots = [
                { y: 0.25, angle: 0.5, size: cfg.knotSize * 1.2 },
                { y: 0.55, angle: 2.8, size: cfg.knotSize },
                { y: 0.75, angle: 4.5, size: cfg.knotSize * 0.8 }
            ];

            // éå†æ‰€æœ‰é¡¶ç‚¹åº”ç”¨ä½ç§»
            for (let i = 0; i < positions.count; i++) {
                let x = positions.getX(i);
                let y = positions.getY(i);
                let z = positions.getZ(i);
                
                // è®¡ç®—å½“å‰ç‚¹çš„åœ†æŸ±åæ ‡
                const angle = Math.atan2(z, x);
                const radius = Math.sqrt(x * x + z * z);
                const heightRatio = (y + cfg.height / 2) / cfg.height; // 0-1
                
                // === 1. Simplex Noise æ ‘çš®ä½ç§» ===
                // ä½¿ç”¨3Då™ªå£°ï¼Œè®©æ ‘çš®çº¹ç†åœ¨å„æ–¹å‘è‡ªç„¶è¿‡æ¸¡
                const noiseX = simplex.noise3D(
                    x * cfg.noiseScale, 
                    y * cfg.noiseScale * 0.5,  // Yæ–¹å‘å‹ç¼©ï¼Œäº§ç”Ÿçºµå‘çº¹ç†
                    z * cfg.noiseScale
                );
                const noiseZ = simplex.noise3D(
                    x * cfg.noiseScale + 100, 
                    y * cfg.noiseScale * 0.5, 
                    z * cfg.noiseScale + 100
                );
                
                // å™ªå£°ä½ç§» (æ²¿å¾„å‘)
                const barkDisplace = noiseX * cfg.noiseStrength;
                
                // === 2. ç»“ç–¤ Bulge ä½ç§» ===
                let knotDisplace = 0;
                for (const knot of knots) {
                    const knotY = knot.y * cfg.height - cfg.height / 2;
                    const distY = Math.abs(y - knotY);
                    const distAngle = Math.min(
                        Math.abs(angle - knot.angle),
                        Math.abs(angle - knot.angle + Math.PI * 2),
                        Math.abs(angle - knot.angle - Math.PI * 2)
                    );
                    
                    // é«˜æ–¯è¡°å‡
                    const knotRadius = knot.size;
                    const dist = Math.sqrt(distY * distY + (distAngle * radius) * (distAngle * radius));
                    if (dist < knotRadius * 2) {
                        const falloff = Math.exp(-(dist * dist) / (knotRadius * knotRadius));
                        knotDisplace += falloff * cfg.knotStrength;
                    }
                }
                
                // === 3. åº”ç”¨æ€»ä½ç§» ===
                const totalDisplace = barkDisplace + knotDisplace;
                const newRadius = radius + totalDisplace;
                
                positions.setX(i, Math.cos(angle) * newRadius);
                positions.setZ(i, Math.sin(angle) * newRadius);
                
                // è½»å¾®Yå‘ä½ç§»å¢åŠ æœ‰æœºæ„Ÿ
                positions.setY(i, y + noiseZ * cfg.noiseStrength * 0.3);
            }
            
            positions.needsUpdate = true;
            trunkGeo.computeVertexNormals(); // é‡æ–°è®¡ç®—æ³•çº¿

            // ç»Ÿä¸€æ ‘çš®æè´¨ - æ ‘å¹²å’Œåˆ†æ”¯å…±ç”¨
            const trunk = new THREE.Mesh(trunkGeo, sharedBarkMaterial);
            trunk.position.y = cfg.height / 2;
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            trunk.userData.isTrunk = true;

            return trunk;
        }
        
        // ============================================
        // ç»Ÿä¸€æ ‘çš®æè´¨ (æ ‘å¹²å’Œåˆ†æ”¯å…±ç”¨)
        // ============================================
        const sharedBarkMaterial = new THREE.MeshStandardMaterial({
                color: 0x4a3728,
            roughness: 0.95,
            metalness: 0,
            flatShading: false
            });

        // ============================================
        // ä¸¥æ ¼ start/end é©±åŠ¨çš„æ ‘æç³»ç»Ÿ
        // ============================================
        const BRANCH_CONFIG = {
            radialSegments: 12,       // åˆ†æ”¯åœ†å‘¨åˆ†æ®µ
            heightSegments: 8,        // åˆ†æ”¯é«˜åº¦åˆ†æ®µ
            collarSize: 1.4,          // æ¥å¤´å¤§å°å€æ•°
            collarTubeRatio: 0.4      // æ¥å¤´ç®¡åŠå¾„æ¯”ä¾‹
        };
        
        // å­˜å‚¨æ‰€æœ‰åˆ†æ”¯æ•°æ®ç”¨äº snapBranchJoints
        let branchDataList = [];
        let collarMeshes = [];
        
        function createBranches(parent) {
            branchDataList = [];
            collarMeshes = [];
            branchMeshes = [];
            
            // è®¡ç®—æ ‘å¹²åœ¨æŒ‡å®šé«˜åº¦çš„åŠå¾„ (çº¿æ€§æ’å€¼)
            function getTrunkRadiusAtHeight(y) {
                const cfg = TRUNK_CONFIG;
                const t = Math.max(0, Math.min(1, y / cfg.height));
                return cfg.radiusBottom + (cfg.radiusTop - cfg.radiusBottom) * t;
            }
            
            // ä¸»åˆ†æ”¯é…ç½® - å®šä¹‰ç›®æ ‡æ–¹å‘å’Œé«˜åº¦
            const mainBranchConfigs = [
                { height: 7.0, angle: 0.5, end: [5, 12, 3], radius: 0.4, id: 'main1' },
                { height: 7.5, angle: 2.5, end: [-4, 13, 2], radius: 0.35, id: 'main2' },
                { height: 8.0, angle: 4.0, end: [3, 14, -4], radius: 0.3, id: 'main3' },
                { height: 6.5, angle: 3.8, end: [-5, 11, -3], radius: 0.38, id: 'main4' },
                { height: 8.5, angle: 1.57, end: [0, 15, 0], radius: 0.35, id: 'main5' },
                { height: 7.2, angle: 5.5, end: [4, 11, -3], radius: 0.32, id: 'main6' },
                { height: 8.8, angle: 2.0, end: [-3, 14, -1], radius: 0.28, id: 'main7' },
                { height: 6.8, angle: 1.0, end: [2, 10, 4], radius: 0.3, id: 'main8' },
            ];

            mainBranchConfigs.forEach(config => {
                // è®¡ç®—åˆ†æ”¯èµ·ç‚¹ - ç¨å¾®æ·±å…¥æ ‘å¹²å†…éƒ¨ä»¥ç¡®ä¿è¿æ¥
                const trunkRadius = getTrunkRadiusAtHeight(config.height);
                // èµ·ç‚¹è®¾ç½®åœ¨æ ‘å¹²å†…éƒ¨ (50% æ·±åº¦) ä»¥ç¡®ä¿é‡å 
                const penetration = trunkRadius * 0.5;
                const effectiveRadius = trunkRadius - penetration;
                const startX = Math.cos(config.angle) * effectiveRadius;
                const startZ = Math.sin(config.angle) * effectiveRadius;
                const startVec = new THREE.Vector3(startX, config.height, startZ);
                const endVec = new THREE.Vector3(...config.end);
                
                // åˆ›å»ºä¸»åˆ†æ”¯æ®µ - ä½¿ç”¨æ›´å¤§çš„åº•éƒ¨åŠå¾„
                const branchData = createBranchSegment(startVec, endVec, config.radius, config.id, null, trunkRadius);
                parent.add(branchData.group);
                branchMeshes.push(branchData.mesh);
                branchDataList.push(branchData);
                
                // ä¸¥æ ¼ä» parent.end å¼€å§‹åˆ›å»ºå­åˆ†æ”¯
                for (let i = 0; i < 3; i++) {
                    // å­åˆ†æ”¯çš„ start ä¸¥æ ¼ç­‰äºçˆ¶åˆ†æ”¯çš„ end
                    const subStart = endVec.clone();
                    const subEnd = subStart.clone().add(new THREE.Vector3(
                        (Math.random() - 0.5) * 3,
                        1 + Math.random() * 2,
                        (Math.random() - 0.5) * 3
                    ));
                    const subRadius = config.radius * 0.5;
                    
                    // ç›´æ¥åˆ›å»ºå­åˆ†æ”¯ï¼ˆæ— æ¥å¤´ï¼‰
                    const subBranchData = createBranchSegment(
                        subStart, subEnd, subRadius, 
                        `${config.id}_sub${i}`,
                        config.id // çˆ¶åˆ†æ”¯ ID
                    );
                    parent.add(subBranchData.group);
                    branchMeshes.push(subBranchData.mesh);
                    branchDataList.push(subBranchData);
                }
            });
        }

        // ============================================
        // åˆ›å»ºå•ä¸ªåˆ†æ”¯æ®µ (ä½¿ç”¨ Unit Cylinder + Group Scale)
        // ============================================
        function createBranchSegment(startVec, endVec, radius, id, parentId = null, connectToTrunkRadius = null) {
            const direction = new THREE.Vector3().subVectors(endVec, startVec);
            const length = direction.length();
            const dirNorm = direction.clone().normalize();
            
            // åˆ›å»º Group ä½œä¸ºåˆ†æ”¯å®¹å™¨
            const group = new THREE.Group();
            group.position.copy(startVec);
            
            // è®¡ç®—åº•éƒ¨åŠå¾„ - å¦‚æœè¿æ¥åˆ°æ ‘å¹²ï¼Œä½¿ç”¨æ›´å¤§çš„åº•éƒ¨ä»¥ç¡®ä¿é‡å 
            let bottomRadius, topRadius;
            if (connectToTrunkRadius) {
                // è¿æ¥åˆ°æ ‘å¹²çš„ä¸»åˆ†æ”¯ï¼šåº•éƒ¨è¦å¤§åˆ°èƒ½è¦†ç›–æ ‘å¹²
                bottomRadius = connectToTrunkRadius * 0.8; // åº•éƒ¨æ¥è¿‘æ ‘å¹²åŠå¾„
                topRadius = radius * 0.5;
            } else {
                // æ™®é€šåˆ†æ”¯
                bottomRadius = radius * 0.85;
                topRadius = radius * 0.45;
            }
            
            // ä½¿ç”¨ Unit Cylinder (é«˜åº¦=1, ä¸­å¿ƒåœ¨ y=0.5)
            // é€šè¿‡ scale.y æ‹‰ä¼¸åˆ°å®é™…é•¿åº¦
            const unitGeo = new THREE.CylinderGeometry(
                topRadius,      // é¡¶éƒ¨åŠå¾„
                bottomRadius,   // åº•éƒ¨åŠå¾„
                1,              // å•ä½é«˜åº¦
                BRANCH_CONFIG.radialSegments,
                BRANCH_CONFIG.heightSegments
            );
            
            // åº”ç”¨æ ‘çš®å™ªå£°å˜å½¢
            applyBarkNoise(unitGeo, startVec, length, radius);
            unitGeo.computeVertexNormals();
            
            const branchMesh = new THREE.Mesh(unitGeo, sharedBarkMaterial);
            
            // å…³é”®: mesh çš„ position.y = 0.5 ä½¿åº•éƒ¨å¯¹é½ group åŸç‚¹
            branchMesh.position.y = 0.5;
            
            // é€šè¿‡ group.scale.y æ‹‰ä¼¸åˆ°å®é™…é•¿åº¦
            group.scale.y = length;
            
            // å¯¹é½æ–¹å‘
            group.quaternion.setFromUnitVectors(
                new THREE.Vector3(0, 1, 0),
                dirNorm
            );
            
            group.add(branchMesh);
            
            branchMesh.castShadow = true;
            branchMesh.receiveShadow = true;
            branchMesh.userData.isBranch = true;
            
            return {
                id: id,
                parentId: parentId,
                group: group,
                mesh: branchMesh,
                start: startVec.clone(),
                end: endVec.clone(),
                direction: dirNorm,
                length: length,
                radius: radius
            };
        }
        
        // å¯¹åˆ†æ”¯å‡ ä½•ä½“åº”ç”¨æ ‘çš®å™ªå£°
        function applyBarkNoise(geometry, startVec, length, radius) {
            const positions = geometry.attributes.position;
            const cfg = TRUNK_CONFIG;
            
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const y = positions.getY(i); // 0 åˆ° 1
                const z = positions.getZ(i);
                
                // è®¡ç®—ä¸–ç•Œåæ ‡ç”¨äºå™ªå£°é‡‡æ ·
                const worldX = startVec.x + x;
                const worldY = startVec.y + y * length;
                const worldZ = startVec.z + z;
                
                const noiseScale = 1.0 - y * 0.4; // é¡¶éƒ¨å™ªå£°å‡å¼±
                const noise = simplex.noise3D(
                    worldX * cfg.noiseScale * 0.8,
                    worldY * cfg.noiseScale * 0.4,
                    worldZ * cfg.noiseScale * 0.8
                ) * cfg.noiseStrength * 0.4 * noiseScale;
                
                const angle = Math.atan2(z, x);
                const r = Math.sqrt(x * x + z * z);
                if (r > 0.01) {
                    const newR = r + noise;
                    positions.setX(i, Math.cos(angle) * newR);
                    positions.setZ(i, Math.sin(angle) * newR);
                }
            }
            positions.needsUpdate = true;
        }
        
        // ============================================
        // åˆ›å»ºåˆ†æ”¯æ¥å¤´ (æœ¨ç»“/collar) - å¹³æ»‘èåˆåˆ°æ ‘å¹²
        // ============================================
        function createBranchCollar(startVec, endVec, branchRadius, trunkRadius = null) {
            const direction = new THREE.Vector3().subVectors(endVec, startVec).normalize();
            const cfg = BRANCH_CONFIG;
            const tcfg = TRUNK_CONFIG;
            
            // æ¥å¤´å¤§å° - å¦‚æœæœ‰æ ‘å¹²åŠå¾„ï¼Œä½¿ç”¨æ›´å¤§çš„æ¥å¤´èå…¥æ ‘å¹²
            const baseSize = trunkRadius 
                ? Math.max(branchRadius * 1.5, trunkRadius * 0.6) 
                : branchRadius * cfg.collarSize;
            
            // ä½¿ç”¨å˜å½¢çš„æ¤­çƒä½“åˆ›å»ºè‡ªç„¶çš„æœ¨ç»“
            const collarGeo = new THREE.SphereGeometry(baseSize, 14, 10);
            const positions = collarGeo.attributes.position;
            
            // è®¡ç®—ä»èµ·ç‚¹æŒ‡å‘æ ‘å¹²ä¸­å¿ƒçš„æ–¹å‘ï¼ˆç”¨äºè®©æ¥å¤´å‘æ ‘å¹²å†…éƒ¨å»¶ä¼¸ï¼‰
            const toCenter = new THREE.Vector3(-startVec.x, 0, -startVec.z).normalize();
            
            for (let i = 0; i < positions.count; i++) {
                let x = positions.getX(i);
                let y = positions.getY(i);
                let z = positions.getZ(i);
                
                // æ²¿åˆ†æ”¯æ–¹å‘å‹æ‰
                const alongBranch = x * direction.x + y * direction.y + z * direction.z;
                x -= alongBranch * direction.x * 0.4;
                y -= alongBranch * direction.y * 0.4;
                z -= alongBranch * direction.z * 0.4;
                
                // å‘æ ‘å¹²æ–¹å‘æ‹‰ä¼¸ï¼ˆåˆ›å»ºèåˆæ•ˆæœï¼‰
                if (trunkRadius) {
                    const toCenterDot = x * toCenter.x + z * toCenter.z;
                    if (toCenterDot > 0) {
                        // å‘æ ‘å¹²å†…éƒ¨å»¶ä¼¸
                        x += toCenter.x * toCenterDot * 0.5;
                        z += toCenter.z * toCenterDot * 0.5;
                    }
                }
                
                // åº”ç”¨æ ‘çš®å™ªå£°
                const worldX = x + startVec.x;
                const worldY = y + startVec.y;
                const worldZ = z + startVec.z;
                
                const noise = simplex.noise3D(
                    worldX * tcfg.noiseScale * 0.8,
                    worldY * tcfg.noiseScale * 0.4,
                    worldZ * tcfg.noiseScale * 0.8
                ) * tcfg.noiseStrength * 0.5;
                
                const dist = Math.sqrt(x * x + z * z);
                if (dist > 0.01) {
                    const scale = 1 + noise;
                    positions.setX(i, x * scale);
                    positions.setZ(i, z * scale);
                } else {
                    positions.setX(i, x);
                    positions.setZ(i, z);
                }
                positions.setY(i, y + noise * 0.15);
            }
            positions.needsUpdate = true;
            collarGeo.computeVertexNormals();
            
            const collar = new THREE.Mesh(collarGeo, sharedBarkMaterial);
            
            // ä½ç½®ç•¥å¾®å‘æ ‘å¹²å†…éƒ¨åç§»
            const offsetPos = startVec.clone();
            if (trunkRadius) {
                offsetPos.add(toCenter.multiplyScalar(baseSize * 0.3));
            }
            collar.position.copy(offsetPos);
            
            // æœå‘åˆ†æ”¯æ–¹å‘å€¾æ–œ
            const upDir = new THREE.Vector3(0, 1, 0);
            const tiltedDir = direction.clone().lerp(upDir, 0.5).normalize();
            collar.quaternion.setFromUnitVectors(upDir, tiltedDir);
            
            collar.castShadow = true;
            collar.receiveShadow = true;
            collar.userData.isCollar = true;
            
            return collar;
        }
        
        // ============================================
        // snapBranchJoints() - ä¿®å¤åˆ†æ”¯æ¥ç¼
        // ç¡®ä¿ child.start === parent.end
        // ============================================
        function snapBranchJoints() {
            branchDataList.forEach(branchData => {
                if (branchData.parentId) {
                    // æ‰¾åˆ°çˆ¶åˆ†æ”¯
                    const parent = branchDataList.find(b => b.id === branchData.parentId);
                    if (parent) {
                        // è®¡ç®—åç§»é‡
                        const offset = new THREE.Vector3().subVectors(parent.end, branchData.start);
                        
                        if (offset.length() > 0.001) {
                            // å¸é™„ start åˆ° parent.end
                            branchData.start.copy(parent.end);
                            
                            // æ›´æ–° group ä½ç½® (ä¿æŒæ–¹å‘å’Œé•¿åº¦ä¸å˜)
                            branchData.group.position.copy(branchData.start);
                            
                            // æ›´æ–° end ä½ç½®
                            branchData.end.copy(branchData.start).add(
                                branchData.direction.clone().multiplyScalar(branchData.length)
                            );
                        }
                    }
                }
            });
            
            // æ›´æ–° collar ä½ç½®
            collarMeshes.forEach((collar, index) => {
                if (index < branchDataList.length) {
                    collar.position.copy(branchDataList[index].start);
                }
            });
        }
        
        // æ—§å‡½æ•°ä¿æŒå‘åå…¼å®¹ (é‡å®šå‘åˆ°æ–°ç³»ç»Ÿ)
        function createBranch(start, end, radius) {
            const startVec = Array.isArray(start) ? new THREE.Vector3(...start) : start;
            const endVec = Array.isArray(end) ? new THREE.Vector3(...end) : end;
            return createBranchSegment(startVec, endVec, radius, 'compat_' + Math.random()).mesh;
        }

        function createFoliage(parent) {
            const leafPositions = [];
            const leafCount = 1000;

            for (let i = 0; i < leafCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI * 0.6;
                const r = 4 + Math.random() * 6;

                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = 12 + r * Math.cos(phi) * 0.7 + Math.random() * 3;
                const z = r * Math.sin(phi) * Math.sin(theta);

                leafPositions.push({ x, y, z });
            }

            // Create leaf clusters
            leafPositions.forEach((pos, i) => {
                const leafGeom = new THREE.SphereGeometry(0.25 + Math.random() * 0.2, 6, 4);
                const leafMat = new THREE.MeshStandardMaterial({
                    color: 0x7cb342,
                    roughness: 0.8,
                    metalness: 0.1,
                    transparent: true,
                    opacity: 0.9
                });
                const leaf = new THREE.Mesh(leafGeom, leafMat);
                leaf.position.set(pos.x, pos.y, pos.z);
                leaf.castShadow = true;
                leaf.userData.originalY = pos.y;
                leaf.userData.originalX = pos.x;
                leaf.userData.phase = Math.random() * Math.PI * 2;
                leaves.push(leaf);
                parent.add(leaf);
            });
        }

        // ============================================
        // åœ°é¢ç³»ç»Ÿ (æ”¯æŒå†¬å­£é›ªåœ°åˆ‡æ¢)
        // ============================================
        const GROUND_CONFIG = {
            radius: 50,
            segments: 64,
            grassColor: 0x4a7c3f,
            snowColor: 0xfafcff,    // æ›´äº®çš„é›ªåœ°é¢œè‰²ï¼Œä¸å¤©ç©ºåŒºåˆ†
            snowRoughness: 0.85,    // ç¨å¾®å…‰æ»‘ä¸€ç‚¹è®©é›ªåœ°æ›´äº®
            snowNoiseScale: 3.0,
            snowNoiseStrength: 0.15
        };
        
        let groundMesh = null;
        let grassMeshes = [];
        let originalGroundMaterial = null;
        let snowGroundMaterial = null;

        function createGround() {
            const cfg = GROUND_CONFIG;
            
            // åˆ›å»ºæ›´é«˜åˆ†æ®µçš„åœ°é¢ä»¥æ”¯æŒé›ªåœ°èµ·ä¼
            const groundGeom = new THREE.CircleGeometry(cfg.radius, cfg.segments * 2);
            
            // åŸå§‹è‰åœ°æè´¨
            originalGroundMaterial = new THREE.MeshStandardMaterial({
                color: cfg.grassColor,
                roughness: 0.95,
                metalness: 0
            });
            
            groundMesh = new THREE.Mesh(groundGeom, originalGroundMaterial);
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);

            // åˆ›å»ºè‰ä¸› (å­˜å‚¨å¼•ç”¨ä»¥ä¾¿å†¬å­£éšè—)
            // é¿å¼€æ²³æµåŒºåŸŸ
            grassMeshes = [];
            const grassCount = 200;
            
            // æ£€æŸ¥ç‚¹æ˜¯å¦åœ¨æ²³æµåŒºåŸŸå†… (ä½¿ç”¨å¤šæ®µçº¿æ®µè¿‘ä¼¼æ›²çº¿)
            function isInRiverArea(x, z) {
                // æ²³æµè·¯å¾„å…³é”®ç‚¹ (ä¸ createRiver ä¸­çš„ curvePoints å¯¹åº”)
                const riverPoints = [
                    [-50, 35], [-30, 28], [-15, 18], [0, 12],
                    [12, 8], [18, -2], [25, -12], [35, -25], [50, -40]
                ];
                const riverWidth = 14; // æ²³æµå®½åº¦ + ç¼“å†²åŒº
                
                // æ£€æŸ¥ç‚¹åˆ°æ²³æµæ¯æ®µçº¿æ®µçš„æœ€çŸ­è·ç¦»
                for (let i = 0; i < riverPoints.length - 1; i++) {
                    const [x1, z1] = riverPoints[i];
                    const [x2, z2] = riverPoints[i + 1];
                    
                    // çº¿æ®µå‘é‡
                    const dx = x2 - x1;
                    const dz = z2 - z1;
                    const segLen = Math.sqrt(dx * dx + dz * dz);
                    
                    // ç‚¹åˆ°çº¿æ®µèµ·ç‚¹çš„å‘é‡
                    const px = x - x1;
                    const pz = z - z1;
                    
                    // æŠ•å½±å‚æ•° t
                    const t = Math.max(0, Math.min(1, (px * dx + pz * dz) / (segLen * segLen)));
                    
                    // çº¿æ®µä¸Šæœ€è¿‘ç‚¹
                    const closestX = x1 + t * dx;
                    const closestZ = z1 + t * dz;
                    
                    // è·ç¦»
                    const dist = Math.sqrt((x - closestX) ** 2 + (z - closestZ) ** 2);
                    if (dist < riverWidth) return true;
                }
                return false;
            }
            
            let created = 0;
            let attempts = 0;
            while (created < grassCount && attempts < 1000) {
                attempts++;
                const angle = Math.random() * Math.PI * 2;
                const radius = 5 + Math.random() * 25;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                
                // è·³è¿‡æ²³æµåŒºåŸŸ
                if (isInRiverArea(x, z)) continue;

                const grassGeom = new THREE.ConeGeometry(0.1, 0.4 + Math.random() * 0.3, 4);
                const grassMat = new THREE.MeshStandardMaterial({
                    color: new THREE.Color().setHSL(0.28, 0.6 + Math.random() * 0.2, 0.35 + Math.random() * 0.15),
                    roughness: 0.9
                });
                const grass = new THREE.Mesh(grassGeom, grassMat);
                grass.position.set(x, 0.15, z);
                grass.rotation.x = (Math.random() - 0.5) * 0.2;
                grass.userData.isGrass = true;
                scene.add(grass);
                grassMeshes.push(grass);
                created++;
            }
            
            // é¢„åˆ›å»ºé›ªåœ°æè´¨å’Œå‡ ä½•ä½“
            createSnowGroundMaterial();
        }
        
        // ============================================
        // åˆ›å»ºé›ªåœ°æè´¨ (å¸¦ Simplex å™ªå£°èµ·ä¼)
        // ============================================
        function createSnowGroundMaterial() {
            const cfg = GROUND_CONFIG;
            
            // åˆ›å»ºç¨‹åºåŒ–é›ªåœ°æ³•çº¿è´´å›¾
            const snowNormalMap = createSnowNormalMap(256);
            
            snowGroundMaterial = new THREE.MeshStandardMaterial({
                color: cfg.snowColor,
                roughness: cfg.snowRoughness,
                metalness: 0,
                normalMap: snowNormalMap,
                normalScale: new THREE.Vector2(0.3, 0.3)
            });
        }
        
        // åˆ›å»ºé›ªåœ°æ³•çº¿è´´å›¾ (é¢—ç²’æ„Ÿ)
        function createSnowNormalMap(size) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(size, size);
            const data = imageData.data;
            
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const i = (y * size + x) * 4;
                    
                    // å¤šå±‚å™ªå£°æ¨¡æ‹Ÿé›ªåœ°é¢—ç²’
                    const nx = x / size;
                    const ny = y / size;
                    
                    const n1 = Math.sin(nx * 50 + Math.random() * 0.5) * Math.cos(ny * 50);
                    const n2 = (Math.random() - 0.5) * 0.3; // ç»†å°é¢—ç²’
                    const n3 = Math.sin(nx * 20) * Math.sin(ny * 20) * 0.2;
                    
                    const dx = (n1 + n2) * 0.15;
                    const dy = (n3 + n2) * 0.15;
                    
                    // RGB ç¼–ç æ³•çº¿
                    data[i] = Math.floor(128 + dx * 127);
                    data[i + 1] = Math.floor(128 + dy * 127);
                    data[i + 2] = 255;
                    data[i + 3] = 255;
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(8, 8);
            return texture;
        }
        
        // ============================================
        // è®¾ç½®å†¬å­£é›ªåœ°
        // ============================================
        function setWinterGround() {
            // éšè—æ‰€æœ‰è‰ä¸›
            grassMeshes.forEach(grass => {
                grass.visible = false;
            });
            
            // éšè—èŠ±æœµ
            flowers.forEach(flower => {
                flower.visible = false;
            });
            
            // åˆ‡æ¢åˆ°é›ªåœ°æè´¨
            if (groundMesh && snowGroundMaterial) {
                groundMesh.material = snowGroundMaterial;
                
                // åº”ç”¨è½»å¾®çš„é¡¶ç‚¹ä½ç§»åˆ›å»ºé›ªåœ°èµ·ä¼
                applySnowDisplacement(groundMesh.geometry);
            }
        }
        
        // å¯¹åœ°é¢åº”ç”¨é›ªåœ°èµ·ä¼
        function applySnowDisplacement(geometry) {
            const positions = geometry.attributes.position;
            const cfg = GROUND_CONFIG;
            
            // å­˜å‚¨åŸå§‹ä½ç½® (é¦–æ¬¡)
            if (!geometry.userData.originalPositions) {
                geometry.userData.originalPositions = positions.array.slice();
            }
            
            const original = geometry.userData.originalPositions;
            
            for (let i = 0; i < positions.count; i++) {
                const x = original[i * 3];
                const y = original[i * 3 + 1];
                const z = original[i * 3 + 2];
                
                // ä½¿ç”¨ Simplex å™ªå£°åˆ›å»ºèµ·ä¼
                const noise = simplex.noise2D(x * cfg.snowNoiseScale * 0.1, z * cfg.snowNoiseScale * 0.1);
                const displacement = noise * cfg.snowNoiseStrength;
                
                positions.setY(i, y + displacement);
            }
            
            positions.needsUpdate = true;
            geometry.computeVertexNormals();
        }
        
        // ============================================
        // æ¢å¤éå†¬å­£åœ°é¢
        // ============================================
        function restoreNonWinterGround() {
            // æ˜¾ç¤ºè‰ä¸›
            grassMeshes.forEach(grass => {
                grass.visible = true;
            });
            
            // èŠ±æœµå¯è§æ€§ç”±æ˜¥å­£é€»è¾‘æ§åˆ¶
            // flowers.forEach(flower => { flower.visible = currentSeason === 0; });
            
            // æ¢å¤è‰åœ°æè´¨
            if (groundMesh && originalGroundMaterial) {
                groundMesh.material = originalGroundMaterial;
                
                // æ¢å¤åŸå§‹åœ°é¢é«˜åº¦
                restoreGroundDisplacement(groundMesh.geometry);
            }
        }
        
        // æ¢å¤åœ°é¢åŸå§‹é«˜åº¦
        function restoreGroundDisplacement(geometry) {
            const positions = geometry.attributes.position;
            
            if (geometry.userData.originalPositions) {
                const original = geometry.userData.originalPositions;
                
                for (let i = 0; i < positions.count; i++) {
                    positions.setX(i, original[i * 3]);
                    positions.setY(i, original[i * 3 + 1]);
                    positions.setZ(i, original[i * 3 + 2]);
                }
                
                positions.needsUpdate = true;
                geometry.computeVertexNormals();
            }
        }

        function createSpringElements() {
            // Apples (clickable projects)
            const applePositions = [
                { x: 3, y: 14, z: 2 },
                { x: -3, y: 13, z: 3 },
                { x: 4, y: 12, z: -2 },
                { x: -2, y: 15, z: -2 },
                { x: 1, y: 13, z: 4 },
                { x: -4, y: 14, z: -1 }
            ];

            applePositions.forEach((pos, i) => {
                const appleGeom = new THREE.SphereGeometry(0.45, 16, 12);
                const appleMat = new THREE.MeshStandardMaterial({
                    color: 0xff4444,
                    roughness: 0.3,
                    metalness: 0.1
                });
                const apple = new THREE.Mesh(appleGeom, appleMat);
                apple.position.set(pos.x, pos.y, pos.z);
                apple.userData.type = 'spring';
                apple.userData.projectId = i;
                apple.userData.originalScale = 1;
                apple.castShadow = true;
                
                // Add stem
                const stemGeom = new THREE.CylinderGeometry(0.03, 0.03, 0.15, 6);
                const stemMat = new THREE.MeshStandardMaterial({ color: 0x4a3728 });
                const stem = new THREE.Mesh(stemGeom, stemMat);
                stem.position.y = 0.5;
                apple.add(stem);
                
                tree.add(apple);
                interactiveObjects.push(apple);
            });

            // Flowers around the tree
            for (let i = 0; i < 40; i++) {
                const flower = createFlower();
                const angle = Math.random() * Math.PI * 2;
                const radius = 3 + Math.random() * 8;
                flower.position.set(
                    Math.cos(angle) * radius,
                    0.1,
                    Math.sin(angle) * radius
                );
                flower.userData.type = 'decoration';
                flower.userData.season = 'spring';
                flower.visible = true;
                flowers.push(flower);
                scene.add(flower);
            }
        }

        function createFlower() {
            const flower = new THREE.Group();
            const colors = [0xff69b4, 0xffb6c1, 0xffc0cb, 0xffffff, 0xffff99];
            const color = colors[Math.floor(Math.random() * colors.length)];

            // Petals
            for (let i = 0; i < 5; i++) {
                const petalGeom = new THREE.SphereGeometry(0.15, 8, 6);
                petalGeom.scale(1, 0.3, 1);
                const petalMat = new THREE.MeshStandardMaterial({
                    color: color,
                    roughness: 0.7
                });
                const petal = new THREE.Mesh(petalGeom, petalMat);
                const angle = (i / 5) * Math.PI * 2;
                petal.position.set(Math.cos(angle) * 0.15, 0.3, Math.sin(angle) * 0.15);
                flower.add(petal);
            }

            // Center
            const centerGeom = new THREE.SphereGeometry(0.08, 8, 6);
            const centerMat = new THREE.MeshStandardMaterial({ color: 0xffff00 });
            const center = new THREE.Mesh(centerGeom, centerMat);
            center.position.y = 0.3;
            flower.add(center);

            // Stem
            const stemGeom = new THREE.CylinderGeometry(0.02, 0.02, 0.3, 6);
            const stemMat = new THREE.MeshStandardMaterial({ color: 0x228b22 });
            const stem = new THREE.Mesh(stemGeom, stemMat);
            stem.position.y = 0.15;
            flower.add(stem);

            return flower;
        }

        function createSummerElements() {
            // Animals (clickable projects)
            const animalConfigs = [
                { type: 'squirrel', pos: { x: 4, y: 10, z: 2 } },
                { type: 'bird', pos: { x: -3, y: 15, z: 2 } },
                { type: 'butterfly', pos: { x: 5, y: 9, z: -1 } },
                { type: 'rabbit', pos: { x: -5, y: 0.5, z: 4 } },
                { type: 'deer', pos: { x: 6, y: 1.5, z: -4 } },
                { type: 'owl', pos: { x: 0, y: 17, z: 0 } }
            ];

            animalConfigs.forEach((config, i) => {
                const animal = createAnimal(config.type);
                animal.position.set(config.pos.x, config.pos.y, config.pos.z);
                animal.userData.type = 'summer';
                animal.userData.projectId = i;
                animal.userData.animalType = config.type;
                animal.userData.originalScale = 1;
                animal.visible = false;
                animals.push(animal);
                scene.add(animal);
                interactiveObjects.push(animal);
            });
        }

        // ============================================
        // å¯è°ƒå‚æ•° - åŠ¨ç‰©
        // ============================================
        const ANIMAL_CONFIG = {
            roughness: 0.85,          // ç»Ÿä¸€ç²—ç³™åº¦ (æ¯›çš®è´¨æ„Ÿ)
            metalness: 0,             // é›¶é‡‘å±åº¦
            segmentsHigh: 16,         // é«˜ç»†èŠ‚çƒä½“åˆ†æ®µ
            segmentsMed: 12           // ä¸­ç­‰ç»†èŠ‚åˆ†æ®µ
        };

        function createAnimal(type) {
            const group = new THREE.Group();
            const cfg = ANIMAL_CONFIG;
            let color;

            // ç»Ÿä¸€æè´¨åˆ›å»ºå‡½æ•°
            const createFurMaterial = (c, roughnessOffset = 0) => new THREE.MeshStandardMaterial({
                color: c,
                roughness: cfg.roughness + roughnessOffset,
                metalness: cfg.metalness
            });

            switch(type) {
                case 'squirrel':
                    color = 0xd2691e;
                    const matS = createFurMaterial(color);
                    const matSLight = createFurMaterial(0xe8a060, -0.1);
                    
                    // èº«ä½“ - æ›´é«˜åˆ†æ®µ
                    const bodyS = new THREE.Mesh(
                        new THREE.SphereGeometry(0.4, cfg.segmentsHigh, cfg.segmentsMed),
                        matS
                    );
                    bodyS.scale.set(1, 0.9, 0.8);
                    bodyS.castShadow = true;
                    bodyS.receiveShadow = true;
                    
                    // å¤´
                    const headS = new THREE.Mesh(
                        new THREE.SphereGeometry(0.28, cfg.segmentsHigh, cfg.segmentsMed),
                        matS
                    );
                    headS.position.set(0.35, 0.25, 0);
                    headS.castShadow = true;
                    
                    // é¼»å­
                    const noseS = new THREE.Mesh(
                        new THREE.SphereGeometry(0.05, 8, 6),
                        new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.3 })
                    );
                    noseS.position.set(0.6, 0.25, 0);
                    
                    // çœ¼ç›
                    const eyeMatS = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.2 });
                    const eyeS1 = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 6), eyeMatS);
                    eyeS1.position.set(0.5, 0.35, 0.12);
                    const eyeS2 = eyeS1.clone();
                    eyeS2.position.set(0.5, 0.35, -0.12);
                    
                    // å°¾å·´ - è“¬æ¾
                    const tailS = new THREE.Mesh(
                        new THREE.SphereGeometry(0.35, cfg.segmentsHigh, cfg.segmentsMed),
                        matSLight
                    );
                    tailS.scale.set(0.4, 1.8, 0.5);
                    tailS.position.set(-0.45, 0.5, 0);
                    tailS.rotation.z = 0.6;
                    tailS.castShadow = true;
                    
                    // è€³æœµ
                    const earS1 = new THREE.Mesh(
                        new THREE.ConeGeometry(0.08, 0.15, 8),
                        matS
                    );
                    earS1.position.set(0.3, 0.5, 0.12);
                    const earS2 = earS1.clone();
                    earS2.position.set(0.3, 0.5, -0.12);
                    
                    group.add(bodyS, headS, noseS, eyeS1, eyeS2, tailS, earS1, earS2);
                    break;

                case 'bird':
                    color = 0x4169e1;
                    const matB = createFurMaterial(color, -0.2);
                    const matBLight = createFurMaterial(0x87ceeb, -0.15);
                    
                    // èº«ä½“
                    const bodyB = new THREE.Mesh(
                        new THREE.SphereGeometry(0.32, cfg.segmentsHigh, cfg.segmentsMed),
                        matB
                    );
                    bodyB.scale.set(1.2, 1, 0.9);
                    bodyB.castShadow = true;
                    bodyB.receiveShadow = true;
                    
                    // èƒ¸éƒ¨ (æµ…è‰²)
                    const chestB = new THREE.Mesh(
                        new THREE.SphereGeometry(0.2, cfg.segmentsMed, 8),
                        matBLight
                    );
                    chestB.position.set(0.15, -0.05, 0);
                    
                    // å¤´
                    const headB = new THREE.Mesh(
                        new THREE.SphereGeometry(0.22, cfg.segmentsHigh, cfg.segmentsMed),
                        matB
                    );
                    headB.position.set(0.35, 0.18, 0);
                    headB.castShadow = true;
                    
                    // å–™
                    const beakB = new THREE.Mesh(
                        new THREE.ConeGeometry(0.06, 0.25, 8),
                        new THREE.MeshStandardMaterial({ color: 0xffa500, roughness: 0.4 })
                    );
                    beakB.rotation.z = -Math.PI / 2;
                    beakB.position.set(0.58, 0.15, 0);
                    
                    // çœ¼ç›
                    const eyeB = new THREE.Mesh(
                        new THREE.SphereGeometry(0.04, 8, 6),
                        new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.2 })
                    );
                    eyeB.position.set(0.45, 0.25, 0.15);
                    const eyeB2 = eyeB.clone();
                    eyeB2.position.z = -0.15;
                    
                    // ç¿…è†€
                    const wingGeoB = new THREE.SphereGeometry(0.25, 8, 6);
                    wingGeoB.scale(0.3, 1, 0.8);
                    const wingB1 = new THREE.Mesh(wingGeoB, matB);
                    wingB1.position.set(-0.1, 0.05, 0.25);
                    wingB1.rotation.x = 0.3;
                    const wingB2 = wingB1.clone();
                    wingB2.position.z = -0.25;
                    wingB2.rotation.x = -0.3;
                    
                    // å°¾å·´
                    const tailB = new THREE.Mesh(
                        new THREE.ConeGeometry(0.15, 0.4, 6),
                        matB
                    );
                    tailB.rotation.z = Math.PI / 2 + 0.3;
                    tailB.position.set(-0.4, 0.1, 0);
                    
                    group.add(bodyB, chestB, headB, beakB, eyeB, eyeB2, wingB1, wingB2, tailB);
                    break;

                case 'butterfly':
                    // èº«ä½“
                    const bodyBu = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.04, 0.06, 0.5, 12),
                        new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.6 })
                    );
                    bodyBu.castShadow = true;
                    
                    // å¤´
                    const headBu = new THREE.Mesh(
                        new THREE.SphereGeometry(0.08, 12, 8),
                        new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.6 })
                    );
                    headBu.position.y = 0.3;
                    
                    // è§¦è§’
                    const antennaMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
                    const ant1 = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.2, 6), antennaMat);
                    ant1.position.set(0.03, 0.4, 0);
                    ant1.rotation.z = -0.3;
                    const ant2 = ant1.clone();
                    ant2.position.x = -0.03;
                    ant2.rotation.z = 0.3;
                    
                    // ç¿…è†€ - æ¸å˜è‰²
                    const wingColors = [0xff69b4, 0xff1493, 0xda70d6];
                    const createWing = (isLeft) => {
                        const wingGroup = new THREE.Group();
                        // ä¸»ç¿…
                        const mainWing = new THREE.Mesh(
                            new THREE.CircleGeometry(0.35, 16),
                            new THREE.MeshStandardMaterial({
                                color: wingColors[0],
                                side: THREE.DoubleSide,
                                transparent: true,
                                opacity: 0.85,
                                roughness: 0.5
                            })
                        );
                        // ä¸‹ç¿…
                        const lowerWing = new THREE.Mesh(
                            new THREE.CircleGeometry(0.25, 12),
                            new THREE.MeshStandardMaterial({
                                color: wingColors[1],
                                side: THREE.DoubleSide,
                                transparent: true,
                                opacity: 0.8,
                                roughness: 0.5
                            })
                        );
                        lowerWing.position.y = -0.2;
                        
                        // ç¿…è†€æ–‘ç‚¹
                        const spot = new THREE.Mesh(
                            new THREE.CircleGeometry(0.08, 8),
                            new THREE.MeshStandardMaterial({
                                color: 0xffffff,
                                side: THREE.DoubleSide,
                                transparent: true,
                                opacity: 0.7
                            })
                        );
                        spot.position.set(0.1, 0.1, 0.01);
                        
                        wingGroup.add(mainWing, lowerWing, spot);
                        wingGroup.position.set(isLeft ? 0.25 : -0.25, 0.1, 0);
                        wingGroup.rotation.y = isLeft ? 0.4 : -0.4;
                        return wingGroup;
                    };
                    
                    const wing1Bu = createWing(true);
                    const wing2Bu = createWing(false);
                    
                    group.add(bodyBu, headBu, ant1, ant2, wing1Bu, wing2Bu);
                    group.userData.wings = [wing1Bu, wing2Bu]; // ä¿å­˜ç¿…è†€å¼•ç”¨ç”¨äºåŠ¨ç”»
                    break;

                case 'rabbit':
                    color = 0xf5f5dc;
                    const matR = createFurMaterial(color);
                    const matRPink = createFurMaterial(0xffcccc, -0.1);
                    
                    // èº«ä½“
                    const bodyR = new THREE.Mesh(
                        new THREE.SphereGeometry(0.55, cfg.segmentsHigh, cfg.segmentsMed),
                        matR
                    );
                    bodyR.scale.set(1, 0.85, 0.9);
                    bodyR.castShadow = true;
                    bodyR.receiveShadow = true;
                    
                    // å¤´
                    const headR = new THREE.Mesh(
                        new THREE.SphereGeometry(0.38, cfg.segmentsHigh, cfg.segmentsMed),
                        matR
                    );
                    headR.position.set(0.55, 0.25, 0);
                    headR.castShadow = true;
                    
                    // é¼»å­
                    const noseR = new THREE.Mesh(
                        new THREE.SphereGeometry(0.05, 8, 6),
                        matRPink
                    );
                    noseR.position.set(0.9, 0.2, 0);
                    
                    // çœ¼ç›
                    const eyeR = new THREE.Mesh(
                        new THREE.SphereGeometry(0.06, 8, 6),
                        new THREE.MeshStandardMaterial({ color: 0x8b0000, roughness: 0.2 })
                    );
                    eyeR.position.set(0.75, 0.4, 0.2);
                    const eyeR2 = eyeR.clone();
                    eyeR2.position.z = -0.2;
                    
                    // è€³æœµ - æ›´é•¿æ›´ç»†è…»
                    const earGeoR = new THREE.CylinderGeometry(0.06, 0.1, 0.6, 12);
                    const ear1R = new THREE.Mesh(earGeoR, matR);
                    ear1R.position.set(0.5, 0.75, 0.12);
                    ear1R.rotation.z = -0.15;
                    ear1R.castShadow = true;
                    const ear2R = ear1R.clone();
                    ear2R.position.z = -0.12;
                    ear2R.rotation.z = 0.15;
                    
                    // è€³æœµå†…éƒ¨ (ç²‰è‰²)
                    const innerEarGeo = new THREE.CylinderGeometry(0.03, 0.06, 0.5, 8);
                    const innerEar1 = new THREE.Mesh(innerEarGeo, matRPink);
                    innerEar1.position.set(0.52, 0.73, 0.12);
                    innerEar1.rotation.z = -0.15;
                    const innerEar2 = innerEar1.clone();
                    innerEar2.position.z = -0.12;
                    
                    // å°¾å·´
                    const tailR = new THREE.Mesh(
                        new THREE.SphereGeometry(0.15, 12, 8),
                        matR
                    );
                    tailR.position.set(-0.5, 0, 0);
                    tailR.castShadow = true;
                    
                    group.add(bodyR, headR, noseR, eyeR, eyeR2, ear1R, ear2R, innerEar1, innerEar2, tailR);
                    break;

                case 'deer':
                    color = 0xcd853f;
                    const matD = createFurMaterial(color);
                    const matDLight = createFurMaterial(0xdeb887);
                    
                    // èº«ä½“
                    const bodyD = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.42, 0.45, 1.4, cfg.segmentsHigh),
                        matD
                    );
                    bodyD.rotation.z = Math.PI / 2;
                    bodyD.castShadow = true;
                    bodyD.receiveShadow = true;
                    
                    // é¢ˆéƒ¨
                    const neckD = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.15, 0.25, 0.6, 12),
                        matD
                    );
                    neckD.position.set(0.6, 0.4, 0);
                    neckD.rotation.z = -0.4;
                    neckD.castShadow = true;
                    
                    // å¤´
                    const headD = new THREE.Mesh(
                        new THREE.SphereGeometry(0.28, cfg.segmentsHigh, cfg.segmentsMed),
                        matD
                    );
                    headD.scale.set(1.3, 1, 0.9);
                    headD.position.set(0.85, 0.7, 0);
                    headD.castShadow = true;
                    
                    // é¼»å­
                    const noseD = new THREE.Mesh(
                        new THREE.SphereGeometry(0.08, 8, 6),
                        new THREE.MeshStandardMaterial({ color: 0x2a1a0a, roughness: 0.5 })
                    );
                    noseD.position.set(1.1, 0.65, 0);
                    
                    // çœ¼ç›
                    const eyeD = new THREE.Mesh(
                        new THREE.SphereGeometry(0.05, 8, 6),
                        new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.2 })
                    );
                    eyeD.position.set(0.95, 0.8, 0.18);
                    const eyeD2 = eyeD.clone();
                    eyeD2.position.z = -0.18;
                    
                    // é¹¿è§’
                    const antlerMat = new THREE.MeshStandardMaterial({ color: 0x4a3520, roughness: 0.7 });
                    const createAntler = (side) => {
                        const antler = new THREE.Group();
                        const main = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.03, 0.05, 0.5, 8),
                            antlerMat
                        );
                        main.rotation.z = side * 0.4;
                        const branch1 = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.02, 0.03, 0.25, 6),
                            antlerMat
                        );
                        branch1.position.set(side * 0.1, 0.15, 0);
                        branch1.rotation.z = side * 0.8;
                        antler.add(main, branch1);
                        antler.position.set(0.75, 1.0, side * 0.15);
                        return antler;
                    };
                    const antler1 = createAntler(1);
                    const antler2 = createAntler(-1);
                    
                    // è…¿
                    const legGeoD = new THREE.CylinderGeometry(0.05, 0.07, 0.9, 10);
                    const legMats = [matD, matDLight];
                    const legs = [];
                    const legPositions = [
                        [0.35, -0.45, 0.22], [-0.35, -0.45, 0.22],
                        [0.35, -0.45, -0.22], [-0.35, -0.45, -0.22]
                    ];
                    legPositions.forEach((pos, i) => {
                        const leg = new THREE.Mesh(legGeoD, matD);
                        leg.position.set(...pos);
                        leg.castShadow = true;
                        legs.push(leg);
                    });
                    
                    // å°¾å·´
                    const tailD = new THREE.Mesh(
                        new THREE.ConeGeometry(0.08, 0.2, 8),
                        matDLight
                    );
                    tailD.position.set(-0.7, 0.1, 0);
                    tailD.rotation.z = Math.PI / 2 + 0.3;
                    
                    group.add(bodyD, neckD, headD, noseD, eyeD, eyeD2, antler1, antler2, tailD, ...legs);
                    break;

                case 'owl':
                    color = 0x8b4513;
                    const matO = createFurMaterial(color);
                    const matOLight = createFurMaterial(0xdeb887);
                    
                    // èº«ä½“
                    const bodyO = new THREE.Mesh(
                        new THREE.SphereGeometry(0.45, cfg.segmentsHigh, cfg.segmentsMed),
                        matO
                    );
                    bodyO.scale.set(1, 1.2, 0.9);
                    bodyO.castShadow = true;
                    bodyO.receiveShadow = true;
                    
                    // èƒ¸éƒ¨ç¾½æ¯›
                    const chestO = new THREE.Mesh(
                        new THREE.SphereGeometry(0.35, cfg.segmentsMed, 8),
                        matOLight
                    );
                    chestO.position.set(0, -0.1, 0.2);
                    chestO.scale.set(0.8, 1, 0.5);
                    
                    // å¤´
                    const headO = new THREE.Mesh(
                        new THREE.SphereGeometry(0.38, cfg.segmentsHigh, cfg.segmentsMed),
                        matO
                    );
                    headO.position.y = 0.55;
                    headO.castShadow = true;
                    
                    // é¢ç›˜
                    const faceO = new THREE.Mesh(
                        new THREE.CircleGeometry(0.3, 16),
                        matOLight
                    );
                    faceO.position.set(0, 0.55, 0.3);
                    
                    // çœ¼ç› - å¤§è€Œåœ†
                    const eyeOuterO = new THREE.Mesh(
                        new THREE.SphereGeometry(0.14, 12, 8),
                        new THREE.MeshStandardMaterial({ color: 0xffff00, roughness: 0.3 })
                    );
                    const eyeInnerO = new THREE.Mesh(
                        new THREE.SphereGeometry(0.06, 8, 6),
                        new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.2 })
                    );
                    eyeOuterO.position.set(0.12, 0.6, 0.3);
                    eyeInnerO.position.set(0.12, 0.6, 0.38);
                    const eyeOuterO2 = eyeOuterO.clone();
                    const eyeInnerO2 = eyeInnerO.clone();
                    eyeOuterO2.position.x = -0.12;
                    eyeInnerO2.position.x = -0.12;
                    
                    // å–™
                    const beakO = new THREE.Mesh(
                        new THREE.ConeGeometry(0.06, 0.15, 8),
                        new THREE.MeshStandardMaterial({ color: 0x4a3520, roughness: 0.5 })
                    );
                    beakO.rotation.x = Math.PI;
                    beakO.position.set(0, 0.45, 0.35);
                    
                    // è€³ç¾½
                    const earTuftGeo = new THREE.ConeGeometry(0.08, 0.2, 6);
                    const earTuft1 = new THREE.Mesh(earTuftGeo, matO);
                    earTuft1.position.set(0.2, 0.85, 0.1);
                    earTuft1.rotation.z = -0.3;
                    const earTuft2 = earTuft1.clone();
                    earTuft2.position.x = -0.2;
                    earTuft2.rotation.z = 0.3;
                    
                    // ç¿…è†€
                    const wingGeoO = new THREE.SphereGeometry(0.35, 8, 6);
                    wingGeoO.scale(0.3, 1, 0.8);
                    const wingO1 = new THREE.Mesh(wingGeoO, matO);
                    wingO1.position.set(0.35, 0, 0);
                    wingO1.castShadow = true;
                    const wingO2 = wingO1.clone();
                    wingO2.position.x = -0.35;
                    
                    group.add(bodyO, chestO, headO, faceO, eyeOuterO, eyeInnerO, eyeOuterO2, eyeInnerO2, beakO, earTuft1, earTuft2, wingO1, wingO2);
                    break;
            }

            // ä¸ºæ‰€æœ‰å­å¯¹è±¡è®¾ç½®é˜´å½±
            group.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
            
            return group;
        }

        function createAutumnElements() {
            // Falling leaves (clickable projects)
            for (let i = 0; i < 6; i++) {
                const leaf = createFallingLeaf(i);
                leaf.userData.type = 'autumn';
                leaf.userData.projectId = i;
                leaf.userData.originalScale = 1;
                leaf.visible = false;
                fallingLeaves.push(leaf);
                scene.add(leaf);
                interactiveObjects.push(leaf);
            }

            // More decorative falling leaves
            for (let i = 0; i < 50; i++) {
                const leaf = createFallingLeaf(-1);
                leaf.userData.type = 'decoration';
                leaf.userData.season = 'autumn';
                leaf.visible = false;
                fallingLeaves.push(leaf);
                scene.add(leaf);
            }
        }

        function createFallingLeaf(projectId) {
            const colors = [0xff6b35, 0xf7c59f, 0xe8a838, 0xc14747, 0xd4a373];
            const color = colors[Math.floor(Math.random() * colors.length)];

            const shape = new THREE.Shape();
            shape.moveTo(0, 0);
            shape.quadraticCurveTo(0.15, 0.1, 0.1, 0.3);
            shape.quadraticCurveTo(0, 0.35, -0.1, 0.3);
            shape.quadraticCurveTo(-0.15, 0.1, 0, 0);

            const geom = new THREE.ShapeGeometry(shape);
            const mat = new THREE.MeshStandardMaterial({
                color,
                side: THREE.DoubleSide,
                roughness: 0.8
            });
            const leaf = new THREE.Mesh(geom, mat);

            leaf.position.set(
                (Math.random() - 0.5) * 20,
                15 + Math.random() * 10,
                (Math.random() - 0.5) * 20
            );
            leaf.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            leaf.userData.fallSpeed = 0.02 + Math.random() * 0.02;
            leaf.userData.swaySpeed = 0.5 + Math.random() * 0.5;
            leaf.userData.swayAmount = 0.3 + Math.random() * 0.3;
            leaf.userData.phase = Math.random() * Math.PI * 2;
            leaf.userData.startY = leaf.position.y;
            leaf.userData.startX = leaf.position.x;

            if (projectId >= 0) {
                leaf.scale.setScalar(2);
            }

            return leaf;
        }

        // ============================================
        // é›ªäººç³»ç»Ÿ
        // ============================================
        let snowman = null;
        let snowmanParts = []; // å¯äº¤äº’çš„é›ªäººéƒ¨ä»¶

        function createSnowman() {
            snowman = new THREE.Group();
            snowman.position.set(0, 0, 0);
            snowman.visible = false;
            
            const snowMat = new THREE.MeshStandardMaterial({
                color: 0xfcfcfc,
                roughness: 0.85,
                metalness: 0
            });
            
            // èº«ä½“ - åº•éƒ¨å¤§çƒ
            const bodyBottom = new THREE.Mesh(
                new THREE.SphereGeometry(2.2, 32, 32),
                snowMat
            );
            bodyBottom.position.y = 2.2;
            bodyBottom.castShadow = true;
            bodyBottom.receiveShadow = true;
            snowman.add(bodyBottom);
            
            // èº«ä½“ - ä¸­é—´çƒ
            const bodyMiddle = new THREE.Mesh(
                new THREE.SphereGeometry(1.6, 32, 32),
                snowMat
            );
            bodyMiddle.position.y = 5.5;
            bodyMiddle.castShadow = true;
            bodyMiddle.receiveShadow = true;
            snowman.add(bodyMiddle);
            
            // å¤´éƒ¨
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(1.2, 32, 32),
                snowMat
            );
            head.position.y = 8.2;
            head.castShadow = true;
            head.receiveShadow = true;
            snowman.add(head);
            
            // === å¯äº¤äº’éƒ¨ä»¶ ===
            
            // å¸½å­ - æ£•è‰²è½¯å‘¢å¸½ (project 0 - Jane's Blog)
            const hatGroup = new THREE.Group();
            const hatMat = new THREE.MeshStandardMaterial({ color: 0x3d2817, roughness: 0.9 });
            // å¸½æª
            const hatBrim = new THREE.Mesh(
                new THREE.CylinderGeometry(1.5, 1.6, 0.12, 32),
                hatMat
            );
            hatBrim.position.y = 9.25;
            hatGroup.add(hatBrim);
            // å¸½èº« - è½¯å‘¢å¸½åœ†é¡¶
            const hatBody = new THREE.Mesh(
                new THREE.SphereGeometry(1.0, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2),
                hatMat
            );
            hatBody.position.y = 9.3;
            hatGroup.add(hatBody);
            // å¸½å¸¦
            const hatBand = new THREE.Mesh(
                new THREE.CylinderGeometry(1.02, 1.02, 0.18, 32),
                new THREE.MeshStandardMaterial({ color: 0x5c3d2e, roughness: 0.7 })
            );
            hatBand.position.y = 9.4;
            hatGroup.add(hatBand);
            hatGroup.userData = { type: 'winter', projectId: 0, partName: 'hat', originalScale: 1 };
            snowman.add(hatGroup);
            snowmanParts.push(hatGroup);
            interactiveObjects.push(hatGroup);
            
            // å·¦çœ¼ (project 1 - AI Relationship Mapper)
            const eyeMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.3 });
            const leftEye = new THREE.Mesh(
                new THREE.SphereGeometry(0.15, 16, 16),
                eyeMat
            );
            leftEye.position.set(-0.35, 8.45, 1.05);
            leftEye.userData = { type: 'winter', projectId: 1, partName: 'leftEye', originalScale: 1 };
            snowman.add(leftEye);
            snowmanParts.push(leftEye);
            interactiveObjects.push(leftEye);
            
            // å³çœ¼ (project 2 - Pawse)
            const rightEye = new THREE.Mesh(
                new THREE.SphereGeometry(0.15, 16, 16),
                eyeMat
            );
            rightEye.position.set(0.35, 8.45, 1.05);
            rightEye.userData = { type: 'winter', projectId: 2, partName: 'rightEye', originalScale: 1 };
            snowman.add(rightEye);
            snowmanParts.push(rightEye);
            interactiveObjects.push(rightEye);
            
            // èƒ¡èåœé¼»å­ (project 3 - Absolute Navigation Lab)
            const nose = new THREE.Mesh(
                new THREE.ConeGeometry(0.15, 0.8, 12),
                new THREE.MeshStandardMaterial({ color: 0xff7733, roughness: 0.7 })
            );
            nose.position.set(0, 8.15, 1.2);
            nose.rotation.x = Math.PI / 2;
            nose.userData = { type: 'winter', projectId: 3, partName: 'nose', originalScale: 1 };
            snowman.add(nose);
            snowmanParts.push(nose);
            interactiveObjects.push(nose);
            
            // å˜´å·´ - å¼¯æ›²çš„å¾®ç¬‘çº¿ (project 4 - Gensync)
            const smileCurve = new THREE.QuadraticBezierCurve3(
                new THREE.Vector3(-0.5, 7.7, 1.1),
                new THREE.Vector3(0, 7.5, 1.2),
                new THREE.Vector3(0.5, 7.7, 1.1)
            );
            const smileGeo = new THREE.TubeGeometry(smileCurve, 16, 0.06, 8, false);
            const smile = new THREE.Mesh(
                smileGeo,
                new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.5 })
            );
            smile.userData = { type: 'winter', projectId: 4, partName: 'mouth', originalScale: 1 };
            snowman.add(smile);
            snowmanParts.push(smile);
            interactiveObjects.push(smile);
            
            // æ ‘ææ‰‹è‡‚æè´¨
            const armMat = new THREE.MeshStandardMaterial({ color: 0x4a3520, roughness: 0.95 });
            
            // å·¦æ‰‹è‡‚ (project 5 - SUAB)
            const leftArmGroup = new THREE.Group();
            const leftArmMain = new THREE.Mesh(
                new THREE.CylinderGeometry(0.06, 0.1, 2.5, 8),
                armMat
            );
            leftArmMain.rotation.z = Math.PI / 2.5;
            leftArmGroup.add(leftArmMain);
            // å°åˆ†æ”¯ (åªä¿ç•™ä¸Šé¢é‚£æ ¹)
            const leftTwig1 = new THREE.Mesh(
                new THREE.CylinderGeometry(0.03, 0.05, 0.6, 6),
                armMat
            );
            leftTwig1.position.set(-0.8, 0.4, 0);
            leftTwig1.rotation.z = Math.PI / 4;
            leftArmGroup.add(leftTwig1);
            leftArmGroup.position.set(-2.5, 5.5, 0);
            leftArmGroup.userData = { type: 'winter', projectId: 5, partName: 'leftArm', originalScale: 1 };
            snowman.add(leftArmGroup);
            snowmanParts.push(leftArmGroup);
            interactiveObjects.push(leftArmGroup);
            
            // å³æ‰‹è‡‚ (è£…é¥°ç”¨ - ä¸å¯äº¤äº’)
            const rightArmGroup = new THREE.Group();
            const rightArmMain = new THREE.Mesh(
                new THREE.CylinderGeometry(0.06, 0.1, 2.5, 8),
                armMat
            );
            rightArmMain.rotation.z = -Math.PI / 2.5;
            rightArmGroup.add(rightArmMain);
            const rightTwig1 = new THREE.Mesh(
                new THREE.CylinderGeometry(0.03, 0.05, 0.6, 6),
                armMat
            );
            rightTwig1.position.set(0.8, 0.4, 0);
            rightTwig1.rotation.z = -Math.PI / 4;
            rightArmGroup.add(rightTwig1);
            rightArmGroup.position.set(2.5, 5.5, 0);
            snowman.add(rightArmGroup);
            
            // çº½æ‰£
            const buttonMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.4 });
            for (let i = 0; i < 3; i++) {
                const button = new THREE.Mesh(
                    new THREE.SphereGeometry(0.12, 10, 10),
                    buttonMat
                );
                button.position.set(0, 4.8 + i * 0.65, 1.5 - i * 0.08);
                snowman.add(button);
            }
            
            // å›´å·¾ - é»„è‰² (åªä¿ç•™å›´è„–éƒ¨åˆ†)
            const scarfMat = new THREE.MeshStandardMaterial({ color: 0xd4a017, roughness: 0.75 });
            // å›´å·¾ä¸»ç¯
            const scarfRing = new THREE.Mesh(
                new THREE.TorusGeometry(1.3, 0.28, 12, 32),
                scarfMat
            );
            scarfRing.position.y = 6.85;
            scarfRing.rotation.x = Math.PI / 2;
            snowman.add(scarfRing);
            
            scene.add(snowman);
        }

        function createWinterElements() {
            // åˆ›å»ºé›ªäºº
            createSnowman();
            
            // å¤§é‡è£…é¥°é›ªèŠ± (å¤§é›ªæ•ˆæœ)
            for (let i = 0; i < 250; i++) {
                const snowflake = createSnowflake(false, -1);
                snowflake.userData.type = 'decoration';
                snowflake.userData.season = 'winter';
                snowflake.visible = false;
                snowflakes.push(snowflake);
                scene.add(snowflake);
            }
        }

        // ============================================
        // é›ªèŠ±ç³»ç»Ÿ (Billboard Sprite - ä¸å˜å½¢)
        // ============================================
        const SNOWFLAKE_CONFIG = {
            interactiveSize: 0.5,     // å¯äº¤äº’é›ªèŠ±å¤§å°
            decorativeMinSize: 0.15,  // è£…é¥°é›ªèŠ±æœ€å°å°ºå¯¸ (å¢å¤§)
            decorativeMaxSize: 0.4,   // è£…é¥°é›ªèŠ±æœ€å¤§å°ºå¯¸ (å¢å¤§)
            fallSpeedMin: 0.015,      // æœ€å°ä¸‹è½é€Ÿåº¦ (åŠ å¿« - å¤§é›ª)
            fallSpeedMax: 0.045,      // æœ€å¤§ä¸‹è½é€Ÿåº¦ (åŠ å¿« - å¤§é›ª)
            swayAmount: 0.4,          // æ‘‡æ‘†å¹…åº¦
            opacity: 0.95,            // é€æ˜åº¦
            alphaTest: 0.1            // Alpha æµ‹è¯•é˜ˆå€¼
        };
        
        let snowflakeTexture = null;
        
        // åˆ›å»ºç¨‹åºåŒ–é›ªèŠ±çº¹ç† (åœ†å½¢/å…­è¾¹å½¢)
        function createSnowflakeTexture() {
            const size = 128;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            // æ¸…é™¤èƒŒæ™¯ (é€æ˜)
            ctx.clearRect(0, 0, size, size);
            
            const cx = size / 2;
            const cy = size / 2;
            const radius = size * 0.4;
            
            // ç»˜åˆ¶å…­è§’é›ªèŠ±
            ctx.strokeStyle = 'white';
            ctx.fillStyle = 'white';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            
            // ä¸­å¿ƒåœ†
            ctx.beginPath();
            ctx.arc(cx, cy, radius * 0.15, 0, Math.PI * 2);
            ctx.fill();
            
            // å…­æ¡ä¸»è‡‚
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
                const armLength = radius;
                
                const endX = cx + Math.cos(angle) * armLength;
                const endY = cy + Math.sin(angle) * armLength;
                
                // ä¸»è‡‚
                ctx.beginPath();
                ctx.moveTo(cx, cy);
                ctx.lineTo(endX, endY);
                ctx.stroke();
                
                // ä¾§æ
                for (let j = 1; j <= 2; j++) {
                    const branchDist = armLength * (0.35 + j * 0.25);
                    const branchX = cx + Math.cos(angle) * branchDist;
                    const branchY = cy + Math.sin(angle) * branchDist;
                    const branchLen = armLength * 0.25 / j;
                    
                    // ä¸¤ä¾§å¯¹ç§°ä¾§æ
                    for (let side = -1; side <= 1; side += 2) {
                        const branchAngle = angle + side * Math.PI / 4;
                        ctx.beginPath();
                        ctx.moveTo(branchX, branchY);
                        ctx.lineTo(
                            branchX + Math.cos(branchAngle) * branchLen,
                            branchY + Math.sin(branchAngle) * branchLen
                        );
                        ctx.stroke();
                    }
                }
            }
            
            // æ·»åŠ å¾„å‘æ¸å˜ä½¿è¾¹ç¼˜æŸ”å’Œ
            const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, radius * 1.2);
            gradient.addColorStop(0, 'rgba(255,255,255,0)');
            gradient.addColorStop(0.8, 'rgba(255,255,255,0)');
            gradient.addColorStop(1, 'rgba(255,255,255,0.5)');
            
            ctx.globalCompositeOperation = 'destination-out';
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, size, size);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }
        
        function createSnowflake(isInteractive, projectId) {
            const cfg = SNOWFLAKE_CONFIG;
            
            // ç¡®ä¿çº¹ç†å·²åˆ›å»º
            if (!snowflakeTexture) {
                snowflakeTexture = createSnowflakeTexture();
            }
            
            const size = isInteractive 
                ? cfg.interactiveSize 
                : cfg.decorativeMinSize + Math.random() * (cfg.decorativeMaxSize - cfg.decorativeMinSize);
            
            // ä½¿ç”¨ Sprite (è‡ªåŠ¨ Billboardï¼Œå§‹ç»ˆé¢å‘ç›¸æœº)
            const spriteMat = new THREE.SpriteMaterial({
                map: snowflakeTexture,
                color: 0xffffff,
                transparent: true,
                opacity: isInteractive ? 1 : cfg.opacity,
                alphaTest: cfg.alphaTest,  // é¿å…ç™½è¾¹
                depthWrite: false,         // é¿å…é€æ˜æ’åºé—®é¢˜
                sizeAttenuation: true      // éšè·ç¦»ç¼©å°
            });
            
            const snowflake = new THREE.Sprite(spriteMat);
            
            // ç­‰æ¯”ç¼©æ”¾ (å…³é”®: Sprite åªæ¥å—ç­‰æ¯”ç¼©æ”¾)
            snowflake.scale.setScalar(size);
            
            // éšæœºä½ç½®
            snowflake.position.set(
                (Math.random() - 0.5) * 30,
                15 + Math.random() * 15,
                (Math.random() - 0.5) * 30
            );

            // è¿åŠ¨å‚æ•°
            snowflake.userData.fallSpeed = cfg.fallSpeedMin + Math.random() * (cfg.fallSpeedMax - cfg.fallSpeedMin);
            snowflake.userData.swaySpeed = 0.3 + Math.random() * 0.3;
            snowflake.userData.swayAmount = cfg.swayAmount * (0.5 + Math.random() * 0.5);
            snowflake.userData.phase = Math.random() * Math.PI * 2;
            snowflake.userData.startY = snowflake.position.y;
            snowflake.userData.startX = snowflake.position.x;
            snowflake.userData.rotSpeed = (Math.random() - 0.5) * 0.02;
            snowflake.userData.baseSize = size;
            
            // äº¤äº’é›ªèŠ±æ ‡è®°
            if (isInteractive) {
                snowflake.userData.type = 'winter';
                snowflake.userData.projectId = projectId;
                snowflake.userData.originalScale = size;
            }

            return snowflake;
        }

        // ============================================
        // å¯è°ƒå‚æ•° - èœ¿èœ’æ²³æµ (æ ·æ¡æ›²çº¿ç”Ÿæˆ)
        // ============================================
        const RIVER_CONFIG = {
            width: 10,                // æ²³æµå®½åº¦ (åŠ å®½)
            segments: 100,            // æ²¿æ ·æ¡æ›²çº¿çš„åˆ†æ®µæ•°
            flowSpeed1: 0.025,        // ç¬¬ä¸€å±‚æ³•çº¿æµé€Ÿ
            flowSpeed2: 0.06,         // ç¬¬äºŒå±‚æ³•çº¿æµé€Ÿ
            normalScale: 0.3,         // æ³•çº¿å¼ºåº¦
            opacity: 0.88,            // é€æ˜åº¦
            roughness: 0.12,          // æ°´é¢ç²—ç³™åº¦
            // æ›´æŸ”å’Œã€æ›´æµ…çš„æ°´è‰²
            color: 0x5b9fbf,          // æµ…è“ç»¿è‰²
            deepColor: 0x3a7a9a,      // æ·±è‰²è°ƒ
            bankColor: 0x8fbc8f,      // æ²³å²¸é¢œè‰²
            waterLevel: 0.02          // æ°´é¢é«˜åº¦ (è´´è¿‘åœ°é¢)
        };

        let riverMesh = null;
        let riverbedMesh = null;
        let riverBanks = [];
        let waterNormal1 = null;
        let waterNormal2 = null;
        let riverCurve = null;
        
        // ============================================
        // è·³é±¼ä¸æ°´èŠ±æ•ˆæœ
        // ============================================
        const FISH_CONFIG = {
            jumpInterval: 3000,       // å¹³å‡è·³è·ƒé—´éš” (ms)
            jumpIntervalRandom: 2000, // éšæœºå˜åŒ–èŒƒå›´
            jumpHeight: 1.2,          // è·³è·ƒé«˜åº¦ (å‡å°)
            jumpDuration: 900,        // è·³è·ƒæŒç»­æ—¶é—´ (ms)
            fishSize: 0.15,           // é±¼çš„å¤§å° (å‡å°)
            splashParticles: 10,      // æ°´èŠ±ç²’å­æ•° (å‡å°‘)
            splashSpeed: 2.0          // æ°´èŠ±é€Ÿåº¦ (å‡æ…¢)
        };
        
        let jumpingFishes = [];
        let splashParticles = [];
        let nextFishJumpTime = 0;

        // ============================================
        // æ²¿æ ·æ¡æ›²çº¿ç”Ÿæˆæ²³æµå‡ ä½•ä½“
        // ============================================
        function createRiverGeometry(curve, width, segments) {
            const geometry = new THREE.BufferGeometry();
            
            const positions = [];
            const uvs = [];
            const indices = [];
            
            const halfWidth = width / 2;
            const points = curve.getSpacedPoints(segments);
            const tangents = [];
            
            // è®¡ç®—æ¯ä¸ªç‚¹çš„åˆ‡çº¿æ–¹å‘
            for (let i = 0; i < points.length; i++) {
                const t = i / (points.length - 1);
                tangents.push(curve.getTangentAt(t));
            }
            
            // ç”Ÿæˆé¡¶ç‚¹
            for (let i = 0; i < points.length; i++) {
                const point = points[i];
                const tangent = tangents[i];
                
                // è®¡ç®—å‚ç›´äºåˆ‡çº¿çš„æ³•çº¿æ–¹å‘ (åœ¨XZå¹³é¢ä¸Š)
                const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                
                // å·¦å³ä¸¤ä¸ªé¡¶ç‚¹
                const leftPoint = point.clone().add(normal.clone().multiplyScalar(-halfWidth));
                const rightPoint = point.clone().add(normal.clone().multiplyScalar(halfWidth));
                
                positions.push(leftPoint.x, leftPoint.y, leftPoint.z);
                positions.push(rightPoint.x, rightPoint.y, rightPoint.z);
                
                // UVåæ ‡: Xæ–¹å‘0-1 (æ²³å®½), Yæ–¹å‘æ²¿æ²³æµé•¿åº¦
                const v = i / (points.length - 1);
                uvs.push(0, v);
                uvs.push(1, v);
            }
            
            // ç”Ÿæˆä¸‰è§’å½¢ç´¢å¼•
            for (let i = 0; i < points.length - 1; i++) {
                const a = i * 2;
                const b = i * 2 + 1;
                const c = (i + 1) * 2;
                const d = (i + 1) * 2 + 1;
                
                // ä¸¤ä¸ªä¸‰è§’å½¢ç»„æˆä¸€ä¸ªå››è¾¹å½¢
                indices.push(a, c, b);
                indices.push(b, c, d);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();
            
            return geometry;
        }

        // ç”Ÿæˆç¨‹åºåŒ–æ³•çº¿è´´å›¾ (é¿å…å¤–éƒ¨çº¹ç†ä¾èµ–)
        function createProceduralNormalMap(size, scale, seed) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(size, size);
            const data = imageData.data;
            
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const i = (y * size + x) * 4;
                    
                    // å¤šå±‚å™ªå£°å åŠ 
                    const nx = x / size * scale;
                    const ny = y / size * scale;
                    
                    const n1 = Math.sin(nx * 6 + seed) * Math.cos(ny * 4 + seed * 0.7);
                    const n2 = Math.sin(nx * 12 + ny * 8 + seed * 1.3) * 0.5;
                    const n3 = Math.cos(nx * 3 - ny * 5 + seed * 0.5) * 0.3;
                    
                    const dx = (n1 + n2) * 0.5;
                    const dy = (n1 + n3) * 0.5;
                    
                    // ç¼–ç ä¸ºRGBæ³•çº¿ (0.5 + 0.5 * value)
                    data[i] = Math.floor(128 + dx * 127);     // R = X
                    data[i + 1] = Math.floor(128 + dy * 127); // G = Y
                    data[i + 2] = 255;                         // B = Z (æœä¸Š)
                    data[i + 3] = 255;                         // A
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        function createRiver() {
            const cfg = RIVER_CONFIG;
            
            // === 1. åˆ›å»ºèœ¿èœ’çš„æ ·æ¡æ›²çº¿è·¯å¾„ ===
            // æ²³æµä»åœºæ™¯è¿œå¤„èœ¿èœ’ç©¿è¿‡ï¼Œå»¶ä¼¸åˆ°é›¾ä¸­æ¶ˆå¤±
            const curvePoints = [
                new THREE.Vector3(-50, 0, 35),    // è¿œå¤„èµ·ç‚¹ (è¢«é›¾éšè—)
                new THREE.Vector3(-30, 0, 28),
                new THREE.Vector3(-15, 0, 18),
                new THREE.Vector3(0, 0, 12),
                new THREE.Vector3(12, 0, 8),      // é è¿‘æ ‘çš„ä½ç½®
                new THREE.Vector3(18, 0, -2),
                new THREE.Vector3(25, 0, -12),
                new THREE.Vector3(35, 0, -25),
                new THREE.Vector3(50, 0, -40)     // è¿œå¤„ç»ˆç‚¹ (è¢«é›¾éšè—)
            ];
            
            riverCurve = new THREE.CatmullRomCurve3(curvePoints, false, 'catmullrom', 0.5);
            
            // === 2. æ²¿æ ·æ¡æ›²çº¿ç”Ÿæˆæ²³æµå‡ ä½•ä½“ ===
            const riverGeo = createRiverGeometry(riverCurve, cfg.width, cfg.segments);
            
            // === 3. æ²³åºŠå‡ ä½•ä½“ (ç•¥å®½ï¼Œåœ¨æ°´é¢ä¸‹æ–¹) ===
            const riverbedGeo = createRiverGeometry(riverCurve, cfg.width + 3, cfg.segments);
            const riverbedMat = new THREE.MeshStandardMaterial({
                color: 0x2a1a0a,
                roughness: 0.95,
                metalness: 0
            });
            riverbedMesh = new THREE.Mesh(riverbedGeo, riverbedMat);
            riverbedMesh.position.y = -0.08; // æ²³åºŠè´´è¿‘åœ°é¢
            riverbedMesh.receiveShadow = true;
            riverbedMesh.userData.type = 'river';
            riverbedMesh.userData.season = 'autumn';
            riverbedMesh.visible = false;
            scene.add(riverbedMesh);
            
            // === 4. æ²³å²¸è¿‡æ¸¡å¸¦ (æ²¿æ ·æ¡æ›²çº¿ç”Ÿæˆ) ===
            const bankColors = [0x7a9b5a, 0x6a8b4a, 0x5a7b3a]; // æ›´æŸ”å’Œçš„ç»¿è‰²
            
            for (let side = -1; side <= 1; side += 2) {
                for (let layer = 0; layer < 3; layer++) {
                    const bankWidth = cfg.width + 2 + layer * 1.5;
                    const bankGeo = createRiverGeometry(riverCurve, bankWidth, cfg.segments);
                    const bankMat = new THREE.MeshStandardMaterial({
                        color: bankColors[layer],
                        roughness: 0.85,
                        metalness: 0,
                transparent: true,
                        opacity: 0.9 - layer * 0.15
                    });
                    const bank = new THREE.Mesh(bankGeo, bankMat);
                    bank.position.y = 0.01 - layer * 0.005; // æ²³å²¸ç•¥é«˜äºåœ°é¢
                    bank.receiveShadow = true;
                    bank.userData.type = 'river';
                    bank.userData.season = 'autumn';
                    bank.visible = false;
                    scene.add(bank);
                    riverBanks.push(bank);
                }
            }
            
            // åˆ›å»ºä¸¤ä¸ªä¸åŒæ¯”ä¾‹çš„ç¨‹åºåŒ–æ³•çº¿è´´å›¾
            waterNormal1 = createProceduralNormalMap(256, 4, 1.0);
            waterNormal2 = createProceduralNormalMap(256, 8, 2.5);
            
            // è®¾ç½®ä¸åŒçš„é‡å¤æ¯”ä¾‹é¿å…æ˜æ˜¾å¹³é“º
            waterNormal1.repeat.set(2, 12);
            waterNormal2.repeat.set(6, 30);
            
            // è‡ªå®šä¹‰æ°´é¢ç€è‰²å™¨ - åŒæ³•çº¿æ··åˆ + è²æ¶…å°”
            const waterVertexShader = `
                varying vec2 vUv;
                varying vec3 vWorldPos;
                varying vec3 vViewDir;
                
                void main() {
                    vUv = uv;
                    vec4 worldPos = modelMatrix * vec4(position, 1.0);
                    vWorldPos = worldPos.xyz;
                    vViewDir = normalize(cameraPosition - worldPos.xyz);
                    gl_Position = projectionMatrix * viewMatrix * worldPos;
                }
            `;
            
            const waterFragmentShader = `
                uniform sampler2D uNormal1;
                uniform sampler2D uNormal2;
                uniform vec2 uOffset1;
                uniform vec2 uOffset2;
                uniform vec3 uShallowColor;
                uniform vec3 uDeepColor;
                uniform vec3 uFogColor;
                uniform float uOpacity;
                uniform float uNormalScale;
                uniform float uFresnelPower;
                uniform float uFogNear;
                uniform float uFogFar;
                
                varying vec2 vUv;
                varying vec3 vWorldPos;
                varying vec3 vViewDir;
                
                void main() {
                    // é‡‡æ ·ä¸¤å±‚æ³•çº¿å¹¶æ··åˆ (è°ƒæ•´UVæ¯”ä¾‹é€‚é…èœ¿èœ’æ²³æµ)
                    vec2 uv1 = vUv * vec2(1.5, 8.0) + uOffset1;
                    vec2 uv2 = vUv * vec2(4.0, 20.0) + uOffset2;
                    
                    vec3 n1 = texture2D(uNormal1, uv1).rgb * 2.0 - 1.0;
                    vec3 n2 = texture2D(uNormal2, uv2).rgb * 2.0 - 1.0;
                    
                    // æ··åˆæ³•çº¿ (ç¬¬äºŒå±‚æƒé‡è¾ƒå°)
                    vec3 normal = normalize(vec3(
                        n1.x * uNormalScale + n2.x * uNormalScale * 0.5,
                        n1.y * uNormalScale + n2.y * uNormalScale * 0.5,
                        1.0
                    ));
                    
                    // è²æ¶…å°”æ•ˆæœ
                    float fresnel = pow(1.0 - max(dot(vViewDir, vec3(0.0, 1.0, 0.0)), 0.0), uFresnelPower);
                    
                    // æ·±åº¦é¢œè‰²æ¸å˜ (åŸºäºUVçš„Xæ–¹å‘æ¨¡æ‹Ÿæ²³æµä¸­å¿ƒæ›´æ·±)
                    float depthFactor = 1.0 - abs(vUv.x - 0.5) * 2.0;
                    depthFactor = smoothstep(0.0, 1.0, depthFactor);
                    vec3 waterColor = mix(uShallowColor, uDeepColor, depthFactor * 0.5);
                    
                    // æ³•çº¿å½±å“çš„é«˜å…‰
                    vec3 lightDir = normalize(vec3(0.5, 1.0, 0.3));
                    vec3 halfVec = normalize(lightDir + vViewDir);
                    float spec = pow(max(dot(normal, halfVec), 0.0), 48.0) * 0.3;
                    
                    // æµåŠ¨é«˜å…‰æ¡çº¹ (æ›´æŸ”å’Œ)
                    float flowStreak = sin(vUv.y * 25.0 + uOffset1.y * 40.0) * 0.5 + 0.5;
                    flowStreak = pow(flowStreak, 6.0) * 0.1;
                    
                    // æœ€ç»ˆé¢œè‰²
                    vec3 finalColor = waterColor;
                    finalColor += vec3(0.75, 0.88, 1.0) * fresnel * 0.35;
                    finalColor += vec3(1.0) * spec;
                    finalColor += vec3(1.0) * flowStreak;
                    
                    // === é›¾æ•ˆæ·¡å‡º (ä½¿æ²³æµç«¯ç‚¹èå…¥é›¾ä¸­) ===
                    float fogDistance = length(vWorldPos - cameraPosition);
                    float fogFactor = smoothstep(uFogNear, uFogFar, fogDistance);
                    finalColor = mix(finalColor, uFogColor, fogFactor);
                    
                    // è¾¹ç¼˜æ·¡å‡º (æ²³æµèµ·å§‹å’Œç»ˆç‚¹)
                    float edgeFade = smoothstep(0.0, 0.1, vUv.y) * smoothstep(1.0, 0.9, vUv.y);
                    float finalOpacity = uOpacity * edgeFade;
                    
                    gl_FragColor = vec4(finalColor, finalOpacity);
                }
            `;
            
            const riverMat = new THREE.ShaderMaterial({
                uniforms: {
                    uNormal1: { value: waterNormal1 },
                    uNormal2: { value: waterNormal2 },
                    uOffset1: { value: new THREE.Vector2(0, 0) },
                    uOffset2: { value: new THREE.Vector2(0, 0) },
                    uShallowColor: { value: new THREE.Color(cfg.color) },
                    uDeepColor: { value: new THREE.Color(cfg.deepColor) },
                    uFogColor: { value: new THREE.Color(0xfaf0e6) }, // åŒ¹é…åœºæ™¯é›¾è‰²
                    uOpacity: { value: cfg.opacity },
                    uNormalScale: { value: cfg.normalScale },
                    uFresnelPower: { value: 2.2 },
                    uFogNear: { value: 25 },
                    uFogFar: { value: 60 }
                },
                vertexShader: waterVertexShader,
                fragmentShader: waterFragmentShader,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            riverMesh = new THREE.Mesh(riverGeo, riverMat);
            riverMesh.position.y = cfg.waterLevel; // æ°´é¢è´´è¿‘åœ°é¢
            riverMesh.userData.type = 'river';
            riverMesh.userData.season = 'autumn';
            riverMesh.visible = false;
            scene.add(riverMesh);
            
            // === åˆ›å»ºè·³é±¼å’Œæ°´èŠ±ç³»ç»Ÿ ===
            createFishAndSplashSystem();
        }
        
        // ============================================
        // è·³é±¼ä¸æ°´èŠ±ç³»ç»Ÿ
        // ============================================
        function createFishAndSplashSystem() {
            // é±¼çš„æè´¨
            const fishMat = new THREE.MeshStandardMaterial({
                color: 0xc0c0c0,
                roughness: 0.3,
                metalness: 0.4
            });
            
            // é¢„åˆ›å»ºå‡ æ¡é±¼ (å¤ç”¨)
            for (let i = 0; i < 3; i++) {
                const fishGroup = new THREE.Group();
                
                // é±¼èº«
                const bodyGeo = new THREE.SphereGeometry(FISH_CONFIG.fishSize, 8, 6);
                bodyGeo.scale(2, 0.6, 0.8);
                const body = new THREE.Mesh(bodyGeo, fishMat);
                fishGroup.add(body);
                
                // é±¼å°¾
                const tailGeo = new THREE.ConeGeometry(FISH_CONFIG.fishSize * 0.5, FISH_CONFIG.fishSize * 0.8, 4);
                const tail = new THREE.Mesh(tailGeo, fishMat);
                tail.position.x = -FISH_CONFIG.fishSize * 1.5;
                tail.rotation.z = Math.PI / 2;
                fishGroup.add(tail);
                
                fishGroup.visible = false;
                fishGroup.userData.type = 'river';
                fishGroup.userData.season = 'autumn';
                fishGroup.userData.isJumping = false;
                scene.add(fishGroup);
                jumpingFishes.push(fishGroup);
            }
            
            // æ°´èŠ±ç²’å­
            const splashGeo = new THREE.SphereGeometry(0.03, 4, 4);
            const splashMat = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8
            });
            
            for (let i = 0; i < 30; i++) {
                const splash = new THREE.Mesh(splashGeo, splashMat.clone());
                splash.visible = false;
                splash.userData.type = 'river';
                splash.userData.season = 'autumn';
                splash.userData.velocity = new THREE.Vector3();
                splash.userData.life = 0;
                scene.add(splash);
                splashParticles.push(splash);
            }
            
            nextFishJumpTime = Date.now() + 1000;
        }
        
        // è§¦å‘é±¼è·³è·ƒ
        function triggerFishJump() {
            const availableFish = jumpingFishes.find(f => !f.userData.isJumping);
            if (!availableFish || !riverCurve) return;
            
            // åœ¨æ²³æµæ›²çº¿ä¸Šéšæœºä½ç½®
            const t = 0.2 + Math.random() * 0.6; // é¿å…å¤ªé è¿‘ç«¯ç‚¹
            const riverPoint = riverCurve.getPointAt(t);
            
            availableFish.position.copy(riverPoint);
            availableFish.position.y = RIVER_CONFIG.waterLevel;
            availableFish.userData.isJumping = true;
            availableFish.userData.jumpStart = Date.now();
            availableFish.userData.startPos = riverPoint.clone();
            availableFish.visible = currentSeason === 2;
            
            // éšæœºè·³è·ƒæ–¹å‘
            const jumpAngle = Math.random() * Math.PI * 2;
            availableFish.userData.jumpDir = new THREE.Vector3(
                Math.cos(jumpAngle) * 0.5,
                0,
                Math.sin(jumpAngle) * 0.5
            );
            
            // ç”Ÿæˆå…¥æ°´æ°´èŠ±
            createSplash(riverPoint.x, RIVER_CONFIG.waterLevel, riverPoint.z);
        }
        
        // åˆ›å»ºæ°´èŠ±
        function createSplash(x, y, z) {
            const cfg = FISH_CONFIG;
            let spawned = 0;
            
            for (let splash of splashParticles) {
                if (splash.userData.life <= 0 && spawned < cfg.splashParticles) {
                    splash.position.set(x, y, z);
                    splash.visible = currentSeason === 2;
                    splash.userData.life = 1.0;
                    
                    // éšæœºå‘å¤–å–·å°„
                    const angle = Math.random() * Math.PI * 2;
                    const speed = cfg.splashSpeed * (0.5 + Math.random() * 0.5);
                    splash.userData.velocity.set(
                        Math.cos(angle) * speed * 0.3,
                        speed * (0.5 + Math.random() * 0.5),
                        Math.sin(angle) * speed * 0.3
                    );
                    spawned++;
                }
            }
        }
        
        // æ›´æ–°è·³é±¼å’Œæ°´èŠ±åŠ¨ç”»
        function updateFishAndSplash(deltaTime) {
            const now = Date.now();
            const cfg = FISH_CONFIG;
            
            // æ£€æŸ¥æ˜¯å¦è¯¥è§¦å‘æ–°çš„è·³è·ƒ
            if (now > nextFishJumpTime && currentSeason === 2) {
                triggerFishJump();
                nextFishJumpTime = now + cfg.jumpInterval + Math.random() * cfg.jumpIntervalRandom;
            }
            
            // æ›´æ–°è·³è·ƒä¸­çš„é±¼
            jumpingFishes.forEach(fish => {
                if (fish.userData.isJumping) {
                    const elapsed = now - fish.userData.jumpStart;
                    const progress = elapsed / cfg.jumpDuration;
                    
                    if (progress >= 1) {
                        // è·³è·ƒç»“æŸ
                        fish.userData.isJumping = false;
                        fish.visible = false;
                        // è½æ°´æ°´èŠ±
                        createSplash(fish.position.x, RIVER_CONFIG.waterLevel, fish.position.z);
                    } else {
                        // æŠ›ç‰©çº¿è¿åŠ¨
                        const jumpY = Math.sin(progress * Math.PI) * cfg.jumpHeight;
                        fish.position.y = RIVER_CONFIG.waterLevel + jumpY;
                        
                        // æ°´å¹³ç§»åŠ¨
                        fish.position.x = fish.userData.startPos.x + fish.userData.jumpDir.x * progress;
                        fish.position.z = fish.userData.startPos.z + fish.userData.jumpDir.z * progress;
                        
                        // æ—‹è½¬é±¼èº«æ¨¡æ‹Ÿè·³è·ƒå§¿æ€
                        fish.rotation.z = (progress - 0.5) * Math.PI * 0.8;
                        
                        // æœå‘ç§»åŠ¨æ–¹å‘
                        fish.rotation.y = Math.atan2(fish.userData.jumpDir.z, fish.userData.jumpDir.x);
                    }
                }
            });
            
            // æ›´æ–°æ°´èŠ±ç²’å­
            splashParticles.forEach(splash => {
                if (splash.userData.life > 0) {
                    splash.userData.life -= deltaTime * 2;
                    
                    // ç‰©ç†è¿åŠ¨
                    splash.userData.velocity.y -= 9.8 * deltaTime;
                    splash.position.add(splash.userData.velocity.clone().multiplyScalar(deltaTime));
                    
                    // é€æ˜åº¦è¡°å‡
                    splash.material.opacity = splash.userData.life * 0.8;
                    
                    // åˆ°è¾¾æ°´é¢æˆ–å¯¿å‘½ç»“æŸæ—¶éšè—
                    if (splash.position.y < RIVER_CONFIG.waterLevel || splash.userData.life <= 0) {
                        splash.visible = false;
                        splash.userData.life = 0;
                    }
                }
            });
        }
        
        // æ²³æµåŠ¨ç”»æ›´æ–°å‡½æ•°
        function updateRiverAnimation(deltaTime) {
            if (!riverMesh || !riverMesh.visible || !riverMesh.material.uniforms) return;
            
            const cfg = RIVER_CONFIG;
            const uniforms = riverMesh.material.uniforms;
            
            // æ»šåŠ¨UVåç§»è€Œéé¡¶ç‚¹ä½ç§»
            uniforms.uOffset1.value.y -= deltaTime * cfg.flowSpeed1;
            uniforms.uOffset2.value.y -= deltaTime * cfg.flowSpeed2;
            uniforms.uOffset2.value.x += deltaTime * 0.005; // è½»å¾®æ¨ªå‘åç§»
            
            // é˜²æ­¢æ•°å€¼è¿‡å¤§
            if (uniforms.uOffset1.value.y < -100) uniforms.uOffset1.value.y += 100;
            if (uniforms.uOffset2.value.y < -100) uniforms.uOffset2.value.y += 100;
        }

        let touchStartX = 0;
        let touchStartY = 0;
        let isSwiping = false;
        let seasonChangeCooldown = false;

        function onKeyDown(e) {
            if (seasonChangeCooldown) return;
            
            if (e.code === 'Space' || e.code === 'ArrowRight') {
                e.preventDefault();
                if (currentSeason < 3) {
                    changeSeason(1);
                }
            } else if (e.code === 'ArrowLeft') {
                e.preventDefault();
                if (currentSeason > 0) {
                    changeSeason(-1);
                }
            }
        }

        function onTouchStart(e) {
            if (e.touches.length === 2) {
                touchStartX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                isSwiping = true;
            }
        }

        function onTouchMove(e) {
            if (!isSwiping || e.touches.length !== 2 || seasonChangeCooldown) return;
            const currentX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
            const deltaX = currentX - touchStartX;
            if (Math.abs(deltaX) > 80) {
                if (deltaX < 0 && currentSeason < 3) {
                    changeSeason(1);
                } else if (deltaX > 0 && currentSeason > 0) {
                    changeSeason(-1);
                }
                isSwiping = false;
            }
        }

        function onTouchEnd() {
            isSwiping = false;
        }

        function onWheel(e) {
            if (seasonChangeCooldown) return;
            
            // Detect horizontal swipe (two finger on trackpad)
            if (Math.abs(e.deltaX) > Math.abs(e.deltaY) && Math.abs(e.deltaX) > 30) {
                e.preventDefault();
                if (e.deltaX > 0 && currentSeason < 3) {
                    changeSeason(1);
                } else if (e.deltaX < 0 && currentSeason > 0) {
                    changeSeason(-1);
                }
            }
        }

        function changeSeason(direction) {
            if (seasonChangeCooldown) return;
            
            targetSeason = Math.max(0, Math.min(3, currentSeason + direction));
            if (targetSeason !== currentSeason) {
                seasonChangeCooldown = true;
                currentSeason = targetSeason;
                updateSeasonUI();
                transitionSeason();
                
                setTimeout(() => {
                    seasonChangeCooldown = false;
                }, 800);
            }
        }
        
        // ç‚¹å‡»è·³è½¬åˆ°æŒ‡å®šå­£èŠ‚
        function jumpToSeason(seasonIndex) {
            if (seasonChangeCooldown || seasonIndex === currentSeason) return;
            if (seasonIndex < 0 || seasonIndex > 3) return;
            
            seasonChangeCooldown = true;
            currentSeason = seasonIndex;
            updateSeasonUI();
            transitionSeason();
            
            setTimeout(() => {
                seasonChangeCooldown = false;
            }, 800);
        }
        
        // è®¾ç½®å­£èŠ‚ç‚¹å‡»åˆ‡æ¢
        function setupSeasonDotClicks() {
            document.querySelectorAll('.scroll-dot').forEach((dot) => {
                dot.style.cursor = 'pointer';
                dot.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const seasonIndex = parseInt(dot.getAttribute('data-season'));
                    jumpToSeason(seasonIndex);
                });
            });
        }

        function updateSeasonUI() {
            // Update season title with animation reset
            document.querySelectorAll('.season-name').forEach(el => {
                el.classList.remove('active');
                el.style.animation = 'none';
                el.offsetHeight; // Trigger reflow
                el.style.animation = '';
            });
            
            const activeTitle = document.getElementById(`${seasons[currentSeason]}Title`);
            activeTitle.classList.add('active');

            // Update dots
            document.querySelectorAll('.scroll-dot').forEach((dot, i) => {
                dot.classList.toggle('active', i === currentSeason);
            });

            // Update hint text
            document.getElementById('hintText').textContent = hintTexts[currentSeason];
        }

        // ============================================
        // å¯è°ƒå‚æ•° - å†¬å­£ç§¯é›ª
        // ============================================
        const SNOW_CONFIG = {
            normalYThreshold: 0.45,   // ä¸–ç•Œæ³•çº¿Yé˜ˆå€¼ (ç¨ä½ä¸€ç‚¹è®©é›ªè¦†ç›–æ›´å¤š)
            snowThickness: 0.12,      // ç§¯é›ªåšåº¦ (å¢åŠ ä¸€ç‚¹å¡«è¡¥ç¼éš™)
            snowRoughness: 0.92,      // ç§¯é›ªç²—ç³™åº¦
            snowOpacity: 0.95,        // ç§¯é›ªé€æ˜åº¦
            snowColor: 0xe8eaec,      // ç§¯é›ªé¢œè‰² (ç¨æ·±çš„ç™½è‰²)
            edgeSoftness: 0.2         // è¾¹ç¼˜è¿‡æ¸¡æŸ”å’Œåº¦ (æ›´æŸ”å’Œçš„è¾¹ç¼˜å¸®åŠ©èåˆ)
        };

        let snowShells = []; // å­˜å‚¨ç§¯é›ª mesh å¼•ç”¨
        let snowShaderMaterial = null; // å…±äº«çš„ç§¯é›ªç€è‰²å™¨æè´¨

        // åˆ›å»ºç§¯é›ªç€è‰²å™¨æè´¨ (åŸºäºä¸–ç•Œæ³•çº¿Yæ§åˆ¶å¯è§æ€§)
        function createSnowShaderMaterial() {
            const cfg = SNOW_CONFIG;
            
            const snowVertexShader = `
                varying vec3 vWorldNormal;
                varying vec3 vWorldPos;
                
                void main() {
                    // è®¡ç®—ä¸–ç•Œç©ºé—´æ³•çº¿
                    vWorldNormal = normalize((modelMatrix * vec4(normal, 0.0)).xyz);
                    vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
                    gl_Position = projectionMatrix * viewMatrix * vec4(vWorldPos, 1.0);
                }
            `;
            
            const snowFragmentShader = `
                uniform vec3 uSnowColor;
                uniform float uOpacity;
                uniform float uThreshold;
                uniform float uSoftness;
                
                varying vec3 vWorldNormal;
                varying vec3 vWorldPos;
                
                void main() {
                    // åŸºäºä¸–ç•Œæ³•çº¿Yåˆ†é‡å†³å®šç§¯é›ªå¯è§æ€§
                    float snowAmount = smoothstep(uThreshold - uSoftness, uThreshold + uSoftness, vWorldNormal.y);
                    
                    // å®Œå…¨æ²¡æœ‰ç§¯é›ªçš„åœ°æ–¹ç›´æ¥ä¸¢å¼ƒ
                    if (snowAmount < 0.01) discard;
                    
                    // ç®€å•å…‰ç…§
                    vec3 lightDir = normalize(vec3(0.5, 1.0, 0.3));
                    float diffuse = max(dot(vWorldNormal, lightDir), 0.3);
                    
                    // è½»å¾®çš„è“è‰²é˜´å½±
                    vec3 shadowColor = vec3(0.85, 0.9, 1.0);
                    vec3 finalColor = mix(shadowColor * 0.7, uSnowColor, diffuse);
                    
                    // ç»†å¾®çš„é—ªå…‰ç‚¹
                    float sparkle = pow(max(dot(vWorldNormal, normalize(vec3(0.3, 1.0, 0.5))), 0.0), 32.0);
                    finalColor += vec3(1.0) * sparkle * 0.2;
                    
                    gl_FragColor = vec4(finalColor, uOpacity * snowAmount);
                }
            `;
            
            return new THREE.ShaderMaterial({
                uniforms: {
                    uSnowColor: { value: new THREE.Color(cfg.snowColor) },
                    uOpacity: { value: cfg.snowOpacity },
                    uThreshold: { value: cfg.normalYThreshold },
                    uSoftness: { value: cfg.edgeSoftness }
                },
                vertexShader: snowVertexShader,
                fragmentShader: snowFragmentShader,
                transparent: true,
                side: THREE.FrontSide,
                depthWrite: true
            });
        }

        // ============================================
        // æ·»åŠ ç§¯é›ªå£³ (å¤åˆ¶å‡ ä½•ä½“å¹¶æ²¿æ³•çº¿æ‰©å±•)
        // ============================================
        function addSnowShell(mesh) {
            if (!mesh.geometry) return null;
            
            const cfg = SNOW_CONFIG;
            
            // å…‹éš†å‡ ä½•ä½“
            const geo = mesh.geometry.clone();
            
            // ç¡®ä¿æœ‰æ³•çº¿
            if (!geo.attributes.normal) {
                geo.computeVertexNormals();
            }
            
            const positions = geo.attributes.position;
            const normals = geo.attributes.normal;
            
            // æ²¿æ³•çº¿æ–¹å‘å‡åŒ€æ‰©å±• (åˆ›å»º"å£³")
            const newPositions = new Float32Array(positions.count * 3);
            
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const y = positions.getY(i);
                const z = positions.getZ(i);
                
                const nx = normals.getX(i);
                const ny = normals.getY(i);
                const nz = normals.getZ(i);
                
                // æ²¿æ³•çº¿æ‰©å±•å›ºå®šåšåº¦
                newPositions[i * 3] = x + nx * cfg.snowThickness;
                newPositions[i * 3 + 1] = y + ny * cfg.snowThickness;
                newPositions[i * 3 + 2] = z + nz * cfg.snowThickness;
            }
            
            geo.setAttribute('position', new THREE.BufferAttribute(newPositions, 3));
            geo.computeVertexNormals();
            
            // ä½¿ç”¨å…±äº«çš„ç€è‰²å™¨æè´¨
            if (!snowShaderMaterial) {
                snowShaderMaterial = createSnowShaderMaterial();
            }
            
            const snowMesh = new THREE.Mesh(geo, snowShaderMaterial);
            
            // å¤åˆ¶åŸ mesh çš„å˜æ¢
            snowMesh.position.copy(mesh.position);
            snowMesh.rotation.copy(mesh.rotation);
            snowMesh.scale.copy(mesh.scale);
            snowMesh.quaternion.copy(mesh.quaternion);
            
            // å¦‚æœåŸ mesh æœ‰çˆ¶çº§ï¼Œéœ€è¦è€ƒè™‘çˆ¶çº§å˜æ¢
            if (mesh.parent && mesh.parent !== scene) {
                // è·å–ä¸–ç•Œå˜æ¢
                const worldPos = new THREE.Vector3();
                const worldQuat = new THREE.Quaternion();
                const worldScale = new THREE.Vector3();
                mesh.getWorldPosition(worldPos);
                mesh.getWorldQuaternion(worldQuat);
                mesh.getWorldScale(worldScale);
                
                snowMesh.position.copy(worldPos);
                snowMesh.quaternion.copy(worldQuat);
                snowMesh.scale.copy(worldScale);
            }
            
            snowMesh.castShadow = true;
            snowMesh.receiveShadow = true;
            snowMesh.userData.isSnow = true;
            snowMesh.visible = false;
            
            return snowMesh;
        }

        // åˆ›å»ºæ‰€æœ‰ç§¯é›ª
        function createSnowShells() {
            // ä¸ºæ ‘å¹²æ·»åŠ ç§¯é›ª
            if (trunkMesh) {
                const trunkSnow = addSnowShell(trunkMesh);
                if (trunkSnow) {
                    scene.add(trunkSnow);
                    snowShells.push(trunkSnow);
                }
            }
            
            // ä¸ºåˆ†æ”¯æ·»åŠ ç§¯é›ª
            branchMeshes.forEach(branch => {
                const branchSnow = addSnowShell(branch);
                if (branchSnow) {
                    scene.add(branchSnow);
                    snowShells.push(branchSnow);
                }
            });
            
            // ä¸å†ä¸ºæ¥å¤´æ·»åŠ ç§¯é›ªï¼ˆå·²ç§»é™¤æ¥å¤´ï¼‰
        }

        function transitionSeason() {
            const season = seasons[currentSeason];
            const colors = seasonColors[season];

            // Background transition
            scene.background = new THREE.Color(colors.bg[0], colors.bg[1], colors.bg[2]);
            scene.fog.color = new THREE.Color(colors.bg[0], colors.bg[1], colors.bg[2]);

            // Update leaves color
            leaves.forEach(leaf => {
                leaf.material.color.setHex(colors.leaves);
            });

            // Toggle seasonal elements
            // Spring elements
            interactiveObjects.forEach(obj => {
                if (obj.userData.type === 'spring') {
                    obj.visible = currentSeason === 0;
                }
            });
            flowers.forEach(f => f.visible = currentSeason === 0);

            // Summer elements
            animals.forEach(a => {
                a.visible = currentSeason === 1;
            });

            // Autumn elements
            fallingLeaves.forEach(l => {
                l.visible = currentSeason === 2;
            });
            
            // æ²³æµåŠæ²³å²¸ (ç§‹å­£)
            scene.children.forEach(child => {
                if (child.userData.type === 'river') {
                    child.visible = currentSeason === 2;
                }
            });
            riverBanks.forEach(bank => {
                bank.visible = currentSeason === 2;
            });

            // Winter elements
            snowflakes.forEach(s => {
                s.visible = currentSeason === 3;
            });

            // === å†¬å­£ç‰¹æ®Šå¤„ç† ===
            if (currentSeason === 3) {
                // å†¬å­£ï¼šéšè—æ•´æ£µæ ‘ï¼Œæ˜¾ç¤ºé›ªäºº
                if (tree) tree.visible = false;
                leaves.forEach(leaf => leaf.visible = false);
                snowShells.forEach(snow => snow.visible = false);
                branchMeshes.forEach(branch => branch.visible = false);
                if (trunkMesh) trunkMesh.visible = false;
                
                // æ˜¾ç¤ºé›ªäººå’Œæ‰€æœ‰å¯äº¤äº’éƒ¨ä»¶
                if (snowman) snowman.visible = true;
                snowmanParts.forEach(part => part.visible = true);
                
                // è®¾ç½®å†¬å­£åœ°é¢ (çº¯ç™½é›ªåœ°)
                setWinterGround();
            } else {
                // éå†¬å­£ï¼šæ˜¾ç¤ºæ ‘ï¼Œéšè—é›ªäºº
                if (tree) tree.visible = true;
                leaves.forEach(leaf => {
                    leaf.visible = true;
                    leaf.material.opacity = 0.9;
                });
                
                snowShells.forEach(snow => {
                    snow.visible = false;
                });
                branchMeshes.forEach(branch => branch.visible = true);
                if (trunkMesh) trunkMesh.visible = true;
                
                // éšè—é›ªäºº
                if (snowman) snowman.visible = false;
                snowmanParts.forEach(part => part.visible = false);
                
                // æ¢å¤éå†¬å­£åœ°é¢
                restoreNonWinterGround();
            }
        }

        // ============================================
        // åŠ¨ç‰©æ‹–æ‹½ç³»ç»Ÿ
        // ============================================
        let isDragging = false;
        let draggedAnimal = null;
        let dragStartTime = 0;
        let dragStartPos = new THREE.Vector2();
        const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); // Y=0 åœ°é¢å¹³é¢
        const DRAG_THRESHOLD = 10; // åƒç´ ï¼ŒåŒºåˆ†ç‚¹å‡»å’Œæ‹–æ‹½
        const CLICK_TIME_THRESHOLD = 500; // æ¯«ç§’ï¼Œå¿«é€Ÿç‚¹å‡»åˆ¤å®šï¼ˆå¢åŠ ï¼‰

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // å¦‚æœæ­£åœ¨æ‹–æ‹½åŠ¨ç‰©
            if (isDragging && draggedAnimal) {
                handleAnimalDrag(event);
                return;
            }

            checkHover();

            const hint = document.getElementById('clickHint');
            if (hoveredObject) {
                hint.style.left = event.clientX + 15 + 'px';
                hint.style.top = event.clientY + 15 + 'px';
                hint.classList.add('visible');
            } else {
                hint.classList.remove('visible');
            }
        }

        function handleAnimalDrag(event) {
            raycaster.setFromCamera(mouse, camera);
            
            // è·å–å°„çº¿ä¸åœ°é¢å¹³é¢çš„äº¤ç‚¹
            const intersectPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(groundPlane, intersectPoint);
            
            if (intersectPoint) {
                // é™åˆ¶åŠ¨ç‰©åœ¨åˆç†èŒƒå›´å†…ç§»åŠ¨
                const clampedX = Math.max(-20, Math.min(20, intersectPoint.x));
                const clampedZ = Math.max(-20, Math.min(20, intersectPoint.z));
                
                // è·å–åŠ¨ç‰©çš„åŸå§‹Yé«˜åº¦åç§» (ä¿æŒåŠ¨ç‰©ä¸è´´åœ°)
                const baseY = draggedAnimal.userData.originalY || draggedAnimal.position.y;
                const animalType = draggedAnimal.userData.animalType;
                
                // æ ¹æ®åŠ¨ç‰©ç±»å‹è®¾ç½®ä¸åŒçš„Yé«˜åº¦
                let targetY = 0.5; // é»˜è®¤åœ°é¢é«˜åº¦
                if (animalType === 'squirrel') targetY = 0.5;
                else if (animalType === 'rabbit') targetY = 0.5;
                else if (animalType === 'deer') targetY = 1.5;
                else if (animalType === 'bird') targetY = intersectPoint.y + 2; // é¸Ÿåœ¨ç©ºä¸­
                else if (animalType === 'butterfly') targetY = intersectPoint.y + 3;
                else if (animalType === 'owl') targetY = intersectPoint.y + 4;
                
                // å¹³æ»‘ç§»åŠ¨
                draggedAnimal.position.x += (clampedX - draggedAnimal.position.x) * 0.3;
                draggedAnimal.position.z += (clampedZ - draggedAnimal.position.z) * 0.3;
                
                // å¯¹äºé£è¡ŒåŠ¨ç‰©ï¼Œå¯ä»¥ç”¨å°„çº¿Yæ¥æ§åˆ¶é«˜åº¦
                if (animalType === 'bird' || animalType === 'butterfly' || animalType === 'owl') {
                    const targetHeight = Math.max(3, Math.min(20, 10 + intersectPoint.y * 0.5));
                    draggedAnimal.position.y += (targetHeight - draggedAnimal.position.y) * 0.3;
                }
            }
            
            document.body.style.cursor = 'grabbing';
        }

        function checkHover() {
            raycaster.setFromCamera(mouse, camera);
            
            const visibleObjects = interactiveObjects.filter(obj => obj.visible);
            const intersects = raycaster.intersectObjects(visibleObjects, true);

            let newHovered = null;

            if (intersects.length > 0) {
                let obj = intersects[0].object;
                // å‘ä¸Šéå†æ‰¾åˆ°å¯äº¤äº’çš„çˆ¶å¯¹è±¡
                while (obj.parent && obj.userData.projectId === undefined) {
                    obj = obj.parent;
                }
                if (obj.userData.projectId !== undefined) {
                    newHovered = obj;
                }
            }
            
            // åªæœ‰å½“æ‚¬åœå¯¹è±¡æ”¹å˜æ—¶æ‰æ›´æ–°ç¼©æ”¾
            if (newHovered !== hoveredObject) {
                // é‡ç½®ä¹‹å‰æ‚¬åœå¯¹è±¡çš„ç¼©æ”¾
                if (hoveredObject && !isDragging) {
                    const scale = hoveredObject.userData.originalScale || 1;
                    hoveredObject.scale.setScalar(scale);
                }
                
                // è®¾ç½®æ–°æ‚¬åœå¯¹è±¡çš„ç¼©æ”¾
                hoveredObject = newHovered;
                if (hoveredObject && !isDragging) {
                    const scale = (hoveredObject.userData.originalScale || 1) * 1.15;
                    hoveredObject.scale.setScalar(scale);
                }
            }
            
            // æ›´æ–°é¼ æ ‡æ ·å¼
            if (hoveredObject) {
                if (hoveredObject.userData.type === 'summer' && currentSeason === 1) {
                    document.body.style.cursor = 'grab';
                } else {
                    document.body.style.cursor = 'pointer';
                }
            } else {
            document.body.style.cursor = 'default';
            }
        }

        function onMouseDown(event) {
            if (event.button !== 0) return; // åªå“åº”å·¦é”®
            
            dragStartTime = Date.now();
            dragStartPos.set(event.clientX, event.clientY);
            
            // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†æ˜¥å­£åŠ¨ç‰©
            if (hoveredObject && hoveredObject.userData.type === 'summer' && currentSeason === 1) {
                isDragging = true;
                draggedAnimal = hoveredObject;
                draggedAnimal.userData.originalY = draggedAnimal.position.y;
                controls.enabled = false; // ç¦ç”¨è½¨é“æ§åˆ¶
                document.body.style.cursor = 'grabbing';
            }
        }

        function onMouseUp(event) {
            const dragDuration = Date.now() - dragStartTime;
            const dragDistance = Math.sqrt(
                Math.pow(event.clientX - dragStartPos.x, 2) + 
                Math.pow(event.clientY - dragStartPos.y, 2)
            );
            
            // é‡ç½®æ‹–æ‹½çŠ¶æ€
            const wasDragging = isDragging;
            if (isDragging) {
                isDragging = false;
                draggedAnimal = null;
                controls.enabled = true; // é‡æ–°å¯ç”¨è½¨é“æ§åˆ¶
            }
            
            // å¦‚æœä¸æ˜¯æ‹–æ‹½åŠ¨ç‰©ï¼Œä¸”ç‚¹å‡»æ—¶é—´/è·ç¦»åœ¨é˜ˆå€¼å†…ï¼Œæ‰“å¼€é¡¹ç›®
            if (!wasDragging && dragDistance < DRAG_THRESHOLD) {
                if (hoveredObject && hoveredObject.userData.projectId !== undefined) {
                    openProject(hoveredObject.userData.projectId);
                }
            }
            
            checkHover();
        }

        function onClick(event) {
            // ä½œä¸ºå¤‡ç”¨ï¼šå¦‚æœ mouseUp æ²¡æœ‰å¤„ç†ï¼Œè¿™é‡Œä¹Ÿå°è¯•æ‰“å¼€é¡¹ç›®
            if (hoveredObject && hoveredObject.userData.projectId !== undefined) {
                // åªæœ‰åœ¨æ²¡æœ‰æ‹–æ‹½çš„æƒ…å†µä¸‹æ‰å¤„ç†
                if (!isDragging) {
                openProject(hoveredObject.userData.projectId);
                }
            }
        }

        function openProject(id) {
            const project = projects[id];
            document.getElementById('modalIcon').textContent = project.icon;
            document.getElementById('modalTitle').textContent = project.title;
            document.getElementById('modalDescription').textContent = project.description;
            
            // æ˜¾ç¤ºçŠ¶æ€ (å¦‚ "In Development")
            const statusEl = document.getElementById('modalStatus');
            statusEl.textContent = project.status || '';
            
            // æ˜¾ç¤ºé“¾æ¥
            const linksEl = document.getElementById('modalLinks');
            linksEl.innerHTML = '';
            if (project.links && project.links.length > 0) {
                project.links.forEach(link => {
                    const a = document.createElement('a');
                    a.href = link.url;
                    a.target = '_blank';
                    a.rel = 'noopener noreferrer';
                    a.className = 'modal-link';
                    a.textContent = link.label;
                    linksEl.appendChild(a);
                });
            }
            
            document.getElementById('projectModal').classList.add('active');
        }

        function closeModal() {
            document.getElementById('projectModal').classList.remove('active');
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function simulateLoading() {
            let progress = 0;
            const progressBar = document.getElementById('loadingProgress');
            const interval = setInterval(() => {
                progress += Math.random() * 15;
                if (progress >= 100) {
                    progress = 100;
                    clearInterval(interval);
                    setTimeout(() => {
                        document.getElementById('loadingScreen').classList.add('hidden');
                    }, 500);
                }
                progressBar.style.width = progress + '%';
            }, 100);
        }

        let lastTime = 0;
        
        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            // è®¡ç®— deltaTime
            const deltaTime = lastTime ? (currentTime - lastTime) / 1000 : 0.016;
            lastTime = currentTime;

            windTime += 0.01;

            // === æ²³æµåŠ¨ç”» (UVæ»šåŠ¨ï¼Œä¸æ˜¯é¡¶ç‚¹ä½ç§») ===
            updateRiverAnimation(deltaTime);
            
            // === è·³é±¼ä¸æ°´èŠ±åŠ¨ç”» (ç§‹å­£) ===
            if (currentSeason === 2) {
                updateFishAndSplash(deltaTime);
            }

            // Animate leaves with wind (éå†¬å­£)
            if (currentSeason !== 3) {
            leaves.forEach((leaf, i) => {
                const windEffect = Math.sin(windTime + leaf.userData.phase) * 0.1;
                leaf.position.y = leaf.userData.originalY + windEffect;
                leaf.position.x = leaf.userData.originalX + Math.sin(windTime * 0.5 + leaf.userData.phase) * 0.05;
            });
            }

            // Animate animals
            animals.forEach((animal, i) => {
                if (animal.visible) {
                    const type = animal.userData.animalType;
                    if (type === 'butterfly') {
                        animal.position.y += Math.sin(windTime * 3 + i) * 0.02;
                        animal.position.x += Math.sin(windTime * 2 + i) * 0.01;
                        // è´è¶ç¿…è†€åŠ¨ç”» - ä½¿ç”¨ä¿å­˜çš„ç¿…è†€å¼•ç”¨
                        if (animal.userData.wings) {
                            animal.userData.wings[0].rotation.y = Math.sin(windTime * 10) * 0.6 + 0.4;
                            animal.userData.wings[1].rotation.y = -Math.sin(windTime * 10) * 0.6 - 0.4;
                        }
                    } else if (type === 'bird') {
                        animal.position.y += Math.sin(windTime * 2 + i) * 0.01;
                        // è½»å¾®è½¬å¤´
                        animal.rotation.y = Math.sin(windTime * 0.5) * 0.1;
                    } else if (type === 'squirrel') {
                        // æ¾é¼ å°¾å·´æ‘†åŠ¨
                        animal.position.y += Math.sin(windTime * 4 + i) * 0.008;
                    } else if (type === 'rabbit') {
                        // å…”å­è½»å¾®è·³åŠ¨
                        animal.position.y += Math.abs(Math.sin(windTime * 3 + i)) * 0.015;
                    } else if (type === 'deer') {
                        // é¹¿è½»å¾®æ™ƒåŠ¨
                        animal.rotation.y = Math.sin(windTime * 0.3) * 0.05;
                    } else if (type === 'owl') {
                        // çŒ«å¤´é¹°è½¬å¤´
                        const head = animal.children.find(c => c.position && c.position.y > 0.4);
                        if (head) {
                            head.rotation.y = Math.sin(windTime * 0.8) * 0.3;
                        }
                    }
                }
            });

            // Animate falling leaves
            fallingLeaves.forEach(leaf => {
                if (leaf.visible) {
                    leaf.position.y -= leaf.userData.fallSpeed;
                    leaf.position.x = leaf.userData.startX + 
                        Math.sin(windTime * leaf.userData.swaySpeed + leaf.userData.phase) * leaf.userData.swayAmount;
                    leaf.rotation.x += 0.01;
                    leaf.rotation.y += 0.02;

                    if (leaf.position.y < 0) {
                        leaf.position.y = leaf.userData.startY;
                        leaf.position.x = (Math.random() - 0.5) * 20;
                        leaf.userData.startX = leaf.position.x;
                    }
                }
            });

            // Animate snowflakes (Sprite - è‡ªåŠ¨ billboard)
            snowflakes.forEach(snowflake => {
                if (snowflake.visible) {
                    // ä¸‹è½
                    snowflake.position.y -= snowflake.userData.fallSpeed;
                    
                    // æ°´å¹³æ‘‡æ‘†
                    snowflake.position.x = snowflake.userData.startX + 
                        Math.sin(windTime * snowflake.userData.swaySpeed + snowflake.userData.phase) * snowflake.userData.swayAmount;
                    
                    // Zè½´è½»å¾®é£˜åŠ¨
                    snowflake.position.z += Math.sin(windTime * 0.5 + snowflake.userData.phase) * 0.002;
                    
                    // Sprite æè´¨æ—‹è½¬ (ä½¿é›ªèŠ±è‡ªè½¬)
                    if (snowflake.material && snowflake.material.rotation !== undefined) {
                        snowflake.material.rotation += snowflake.userData.rotSpeed;
                    }
                    
                    // ç¡®ä¿ç­‰æ¯”ç¼©æ”¾ (é¿å…ä»»ä½•çˆ¶çº§å½±å“)
                    const baseSize = snowflake.userData.baseSize || 0.1;
                    snowflake.scale.setScalar(baseSize);

                    // é‡ç½®åˆ°é¡¶éƒ¨
                    if (snowflake.position.y < 0) {
                        snowflake.position.y = snowflake.userData.startY;
                        snowflake.position.x = (Math.random() - 0.5) * 30;
                        snowflake.position.z = (Math.random() - 0.5) * 30;
                        snowflake.userData.startX = snowflake.position.x;
                    }
                }
            });

            controls.update();
            renderer.render(scene, camera);
        }

        // Initialize
        init();
        
        // åˆ›å»ºç§¯é›ªå£³ (å¿…é¡»åœ¨æ ‘åˆ›å»ºå)
        createSnowShells();
        
        transitionSeason();
    </script>
</body>
</html>
